# 硅谷课堂-智慧星球 Day 9~Day 12——尚硅谷项目笔记 2022 年

[TOC]

## Day 9-点播管理模块（三）

### 一、点播管理模块-课程统计

#### 1、课程统计需求

![课程统计需求](https://img-blog.csdnimg.cn/ebaf7e00a63b47899b77f9ab43dd5454.png)

![课程统计需求](https://img-blog.csdnimg.cn/059b3c8cd5d84afe9d5c923e3a26ab66.png)

#### 2、课程统计接口

##### 2.1、创建相关代码

![创建相关代码](https://img-blog.csdnimg.cn/5b08f2f6e53041139bde0da9208cac15.png)

##### 2.2、编写 Controller

**VideoVisitorController**

```java
package com.myxh.smart.planet.vod.controller;

import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vod.service.VideoVisitorService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/10
 *
 * <p>
 * 视频来访者记录 前端控制器
 * </p>
 */
@Tag(name = "视频来访者记录接口", description = "视频来访者记录管理接口")
@RestController
@RequestMapping("admin/vod/video/visitor")
@CrossOrigin
public class VideoVisitorController
{
    @Autowired
    private VideoVisitorService videoVisitorService;

    /**
     * 显示课程统计数据
     *
     * @param courseId  课程 id
     * @param startDate 开始时间
     * @param endDate   结束时间
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "显示课程统计数据", description = "显示课程统计数据")
    @GetMapping("find/count/{courseId}/{startDate}/{endDate}")
    public Result<Map<String, Object>> showChart(
            @Parameter(name = "courseId", description = "课程ID") @PathVariable("courseId") Long courseId,
            @Parameter(name = "startDate", description = "开始时间") @PathVariable("startDate") String startDate,
            @Parameter(name = "endDate", description = "结束时间") @PathVariable("endDate") String endDate)
    {
        Map<String, Object> countMap = videoVisitorService.findCount(courseId, startDate, endDate);

        return Result.ok(countMap);
    }
}
```

##### 2.3、编写 Service 和实现

**VideoVisitorService 和 VideoVisitorServiceImpl。**

```java
package com.myxh.smart.planet.vod.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.vod.VideoVisitor;
import com.myxh.smart.planet.vo.vod.VideoVisitorCountVo;
import com.myxh.smart.planet.vod.mapper.VideoVisitorMapper;
import com.myxh.smart.planet.vod.service.VideoVisitorService;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author MYXH
 * @date 2023/10/10
 *
 *
 * <p>
 * 视频来访者记录 服务实现类
 * </p>
 */
@Service
public class VideoVisitorServiceImpl extends ServiceImpl<VideoVisitorMapper, VideoVisitor> implements VideoVisitorService
{
    /**
     * 显示课程统计数据
     *
     * @param courseId  课程 id
     * @param startDate 开始时间
     * @param endDate   结束时间
     * @return countMap 课程统计数据
     */
    @Override
    public Map<String, Object> findCount(Long courseId, String startDate, String endDate)
    {
        // 调用 mapper 的方法
        List<VideoVisitorCountVo> videoVisitorVoList = baseMapper.findCount(courseId, startDate, endDate);

        // 创建 countMap 集合
        Map<String, Object> countMap = new HashMap<>();

        // 创建两个 list 集合，一个代表所有日期，一个代表日期对应数量
        // 代表所有日期
        List<String> dateList = videoVisitorVoList.stream().map(VideoVisitorCountVo::getJoinTime)
                .collect(Collectors.toList());

        // 代表日期对应数量
        List<Integer> countList = videoVisitorVoList.stream().map(VideoVisitorCountVo::getUserCount)
                .collect(Collectors.toList());

        // 放到 countMap 集合
        countMap.put("xData", dateList);
        countMap.put("yData", countList);

        return countMap;
    }
}
```

##### 2.4、编写 Mapper

**（1）VideoVisitorMapper**

```java
package com.myxh.smart.planet.vod.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.myxh.smart.planet.model.vod.VideoVisitor;
import com.myxh.smart.planet.vo.vod.VideoVisitorCountVo;
import org.apache.ibatis.annotations.Param;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/10
 *
 * <p>
 * 视频来访者记录 Mapper 接口
 * </p>
 */
public interface VideoVisitorMapper extends BaseMapper<VideoVisitor>
{
    /**
     * 显示课程统计数据
     *
     * @param courseId  课程 id
     * @param startDate 开始时间
     * @param endDate   结束时间
     * @return countMap 课程统计数据
     */
    List<VideoVisitorCountVo> findCount(
            @Param("courseId") Long courseId,
            @Param("startDate") String startDate,
            @Param("endDate") String endDate);
}
```

**（2）VideoVisitorMapper.xml 文件。**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.myxh.smart.planet.vod.mapper.VideoVisitorMapper">
    <select id="findCount" resultType="com.myxh.smart.planet.vo.vod.VideoVisitorCountVo">
        SELECT
        DATE(join_time) AS joinTime,
        COUNT(*) AS userCount
        FROM video_visitor
        <where>
            <if test="startDate != null and startDate != ''">
                AND DATE(join_time) &gt;= #{startDate}
            </if>
            <if test="endDate != null and endDate != ''">
                AND DATE(join_time) &lt;= #{endDate}
            </if>
            AND course_id=#{courseId}
        </where>
        GROUP BY DATE(join_time)
        ORDER BY DATE(join_time)
    </select>
</mapper>
```

#### 3、课程统计前端

##### 3.1、定义接口

**创建 videoVisitor.js 定义接口。**

```javascript
import request from "@/utils/request";

const VIDEO_VISITOR_API = "/admin/vod/video/visitor";

export default {
  /**
   * 显示课程统计数据
   *
   * @param {number} courseId  课程 id
   * @param {String} startDate 开始时间
   * @param {String} endDate   结束时间
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  findCount(courseId, startDate, endDate) {
    return request({
      url: `${VIDEO_VISITOR_API}/find/count/${courseId}/${startDate}/${endDate}`,
      method: "get",
    });
  },
};
```

##### 3.2、安装 ECharts 组件

ECharts 是百度的一个项目，后来百度把 Echart 捐给 apache，用于图表展示，提供了常规的[折线/面积图](https://echarts.apache.org/zh/option.html#series-line)、[散点（气泡）图](https://echarts.apache.org/zh/option.html#series-scatter)、[饼图](https://echarts.apache.org/zh/option.html#series-pie)、[K 线图](https://echarts.apache.org/zh/option.html#series-candlestick)，用于统计的[箱形图](https://echarts.apache.org/zh/option.html#series-boxplot)，用于地理数据可视化的[地图](https://echarts.apache.org/zh/option.html#series-map)、[热力图](https://echarts.apache.org/zh/option.html#series-heatmap)、[路径图](https://echarts.apache.org/zh/option.html#series-lines)，用于关系数据可视化的[关系图](https://echarts.apache.org/zh/option.html#series-graph)、[Treemap](https://echarts.apache.org/zh/option.html#series-treemap)、[旭日图](https://echarts.apache.org/zh/option.html#series-sunburst)，多维数据可视化的[平行坐标图](https://echarts.apache.org/zh/option.html#series-parallel)，还有用于 BI 的[漏斗图](https://echarts.apache.org/zh/option.html#series-funnel)，[仪表盘](https://echarts.apache.org/zh/option.html#series-gauge)，并且支持图与图之间的混搭。

官方网站：https://echarts.apache.org/zh/index.html

```shell
npm install --save echarts@5.4.3
```

##### 3.3、编写页面

**创建 chart.vue 页面。**

![编写页面](https://img-blog.csdnimg.cn/6d84dd39e6cf45a3bb81057586443217.png)

```html
<template>
  <div class="app-container">
    <!-- 表单 -->
    <el-form :inline="true" class="demo-form-inline">
      <el-form-item>
        <el-date-picker
          v-model="startDate"
          type="date"
          placeholder="选择开始日期"
          value-format="yyyy-MM-dd"
        />
      </el-form-item>
      <el-form-item>
        <el-date-picker
          v-model="endDate"
          type="date"
          placeholder="选择截止日期"
          value-format="yyyy-MM-dd"
        />
      </el-form-item>
      <el-button
        :disabled="btnDisabled"
        type="primary"
        icon="el-icon-search"
        @click="showChart()"
        >查询</el-button
      >
    </el-form>
    <div id="chart" class="chart" style="height: 500px" />
  </div>
</template>

<script>
  import * as echarts from "echarts";
  import videoVisitorAPI from "@/api/vod/videoVisitor";

  export default {
    data() {
      return {
        courseId: "",
        startDate: "",
        endDate: "",
        btnDisabled: false,
      };
    },

    created() {
      this.courseId = this.$route.params.id;

      // 初始化最近十天数据
      let currentDate = new Date();
      this.startDate = this.dateFormat(
        new Date(currentDate.getTime() - 7 * 24 * 3600 * 1000)
      );

      this.endDate = this.dateFormat(currentDate);
      this.showChart();
    },

    methods: {
      showChart() {
        videoVisitorAPI
          .findCount(this.courseId, this.startDate, this.endDate)
          .then((response) => {
            this.setChartData(response.data);
          });
      },

      setChartData(data) {
        // 基于准备好的 dom，初始化 echarts 实例
        let myChart = echarts.init(document.getElementById("chart"));

        // 指定图表的配置项和数据
        let option = {
          title: {
            text: "观看课程人数统计",
          },

          xAxis: {
            data: data.xData,
          },

          yAxis: {
            minInterval: 1,
          },

          series: [
            {
              type: "line",
              data: data.yData,
            },
          ],
        };

        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
      },

      dateFormat(date) {
        let fmt = "YYYY-mm-dd";
        let ret;

        const opt = {
          // 年
          "Y+": date.getFullYear().toString(),
          // 月
          "m+": (date.getMonth() + 1).toString(),
          // 日
          "d+": date.getDate().toString(),
          // 时
          "H+": date.getHours().toString(),
          // 分
          "M+": date.getMinutes().toString(),
          // 秒
          "S+": date.getSeconds().toString(),
          // 有其他格式化字符需求可以继续添加，必须转化成字符串
        };

        for (let k in opt) {
          ret = new RegExp("(" + k + ")").exec(fmt);

          if (ret) {
            fmt = fmt.replace(
              ret[1],
              ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, "0")
            );
          }
        }

        return fmt;
      },
    },
  };
</script>
```

### 二、整合腾讯云点播

#### 1、功能需求介绍

##### 1.1、上传视频

在发布课程时候，需要添加课时并且上传课程视频，这个时候需要使用到腾讯云点播服务进行上传视频管理。

![上传视频](https://img-blog.csdnimg.cn/2e29cbceb0c44ab3955d1bafc70049c7.png)

##### 1.2、删除视频

（1）添加小节，上传课程视频。

（2）删除小节时候，需要删除视频。

（3）删除章节时候，需要删除章节，小节和视频。

（4）删除课程时候，需要删除课程，章节，小节和视频。

##### 1.3、视频播放（后续完成）

#### 2、腾讯云点播介绍

腾讯云点播（Video on Demand，VOD）基于腾讯多年技术积累与基础设施建设，为有音视频应用相关需求的客户提供包括音视频存储管理、音视频转码处理、音视频加速播放和音视频通信服务的一站式解决方案。

![腾讯云点播介绍](https://img-blog.csdnimg.cn/609975881d7940bfb9764ad4d61683b8.png)

文档中心：https://cloud.tencent.com/document/product/266

##### 2.1、开通"云点播"服务

![开通"云点播"服务](https://img-blog.csdnimg.cn/09e8336ccc2842899c16191321f7243c.png)

##### 2.2、管理控制台

![管理控制台](https://img-blog.csdnimg.cn/7f9d4687b7fd4d1f895d97ffc088843f.png)

##### 2.3、上传视频

上传视频可将视频上传到云点播的存储中，以进行后续的处理和分发等。

- 单击左侧菜单栏【媒资管理 > 视频管理】，默认展示【已上传】标签页；

- 点击【上传视频】按钮；

- 单击【选择视频】，选择本地视频文件；

- 单击【开始上传】；

- 页面将自动跳转至【正在上传】标签页， 本地文件所在行【状态】栏为“上传成功”时，单击【已上传】标签页，可见完成上传的视频；

  ![上传视频](https://img-blog.csdnimg.cn/3b188601f03e4afcb0087688b55b7ab3.png)

- 单击【管理】，可以查看视频详情。

  ![上传视频](https://img-blog.csdnimg.cn/9c906506d38c48c4940780835b752262.png)

##### 2.4、前端集成

前端集成有两种方式，使用“超级播放器预览”与“web 播放器预览”，后者代码已经不更新，推荐使用前者，因此“web 播放器预览”仅做了解。

1、查看“web 播放器预览”。

![前端集成](https://img-blog.csdnimg.cn/cce012db4a284551aa9c4831655b1e19.png)

说明：需要将视频进行转码，才能支持超级播放器播放，转码为：自适应码流。

2、查看“任务流设置”。

![前端集成](https://img-blog.csdnimg.cn/4c99cd26b491489ab8dd828ca7845f1c.png)

3、查看详情。

![前端集成](https://img-blog.csdnimg.cn/e71698845c0f407fae3df4d35d91989e.png)

当前任务流就是系统默认的“自适应码流”任务流。

4、在【音视频管理】重新上传视频。

![前端集成](https://img-blog.csdnimg.cn/42cb8593045147ffa6938c158df56a7b.png)

5、查看详情。

![前端集成](https://img-blog.csdnimg.cn/eca9af345d034cd787fd87f2e896ef8e.png)

6、复制代码 index.html 到项目，即可播放。

#### 3、编写视频点播接口

##### 3.1、创建相关类

![创建相关类](https://img-blog.csdnimg.cn/81e35b2c07bd460fa76075d7d2973847.png)

##### 3.2、引入相关依赖

**（1）在 service-vod 模块引入。**

```xml
<!-- 腾讯云点播（Video on Demand，VOD） -->
<dependency>
    <groupId>com.qcloud</groupId>
    <artifactId>vod_api</artifactId>
    <version>2.1.5</version>
    <exclusions>
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

##### 3.3、编写 Controller

**（1）上传视频集成方案：** https://cloud.tencent.com/document/product/266/10276

![编写 Controller](https://img-blog.csdnimg.cn/3deed185b68a4d0e99b6dd6deb5752f9.png)

**（2）删除视频。**

可在线生成代码。

地址：https://console.cloud.tencent.com/api/explorer?Product=vod&Version=2018-07-17&Action=DeleteMedia

![编写 Controller](https://img-blog.csdnimg.cn/a3e4481908064251ae7a5c06de93a56d.png)

```java
package com.myxh.smart.planet.vod.controller;

import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vod.service.VodService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;

/**
 * @author MYXH
 * @date 2023/10/11
 */
@Tag(name = "腾讯云点播接口", description = "腾讯云点播接口")
@RestController
@RequestMapping("/admin/vod")
@CrossOrigin
public class VodController
{
    @Autowired
    private VodService vodService;

    /**
     * 上传视频
     *
     * @param file 文件
     * @return videoId 视频 id
     * @throws IOException IO 异常
     */
    @Operation(summary = "上传", description = "上传视频")
    @PostMapping(value = "upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public Result<String> uploadVideo(@Parameter(name = "file", description = "文件", required = true)
                                      @RequestParam("file") MultipartFile file) throws IOException
    {
        InputStream inputStream = file.getInputStream();
        String originalFilename = file.getOriginalFilename();
        String videoId = vodService.uploadVideo(inputStream, originalFilename);

        return Result.ok(videoId);
    }

    /**
     * 删除视频
     *
     * @param videoSourceId 视频源 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除", description = "删除视频")
    @DeleteMapping("remove/{videoSourceId}")
    public Result<Void> removeVideo(@Parameter(name = "videoSourceId", description = "视频源 id", required = true)
                                    @PathVariable("videoSourceId") String videoSourceId)
    {
        vodService.removeVideo(videoSourceId);

        return Result.ok(null);
    }
}
```

##### 3.4、编写 Service

**（1）VodService 定义方法。**

```java
package com.myxh.smart.planet.vod.service;

import java.io.InputStream;

/**
 * @author MYXH
 * @date 2023/10/11
 */
public interface VodService
{
    /**
     * 上传视频
     *
     * @param inputStream 输入流
     * @param originalFilename 原始文件名
     * @return videoId 视频 id
     */
    String uploadVideo(InputStream inputStream, String originalFilename);

    /**
     * 删除视频
     *
     * @param videoSourceId 视频源 id
     */
    void removeVideo(String videoSourceId);
}
```

**（2）VodServiceImpl 实现方法。**

```java
package com.myxh.smart.planet.vod.service.impl;

import com.myxh.smart.planet.exception.SmartPlanetException;
import com.myxh.smart.planet.vod.service.VodService;
import com.myxh.smart.planet.vod.utils.ConstantPropertiesUtil;
import com.qcloud.vod.VodUploadClient;
import com.qcloud.vod.model.VodUploadRequest;
import com.qcloud.vod.model.VodUploadResponse;
import com.tencentcloudapi.common.Credential;
import com.tencentcloudapi.common.exception.TencentCloudSDKException;
import com.tencentcloudapi.vod.v20180717.VodClient;
import com.tencentcloudapi.vod.v20180717.models.DeleteMediaRequest;
import com.tencentcloudapi.vod.v20180717.models.DeleteMediaResponse;
import org.apache.ibatis.javassist.LoaderClassPath;
import org.springframework.stereotype.Service;

import java.io.InputStream;

/**
 * @author MYXH
 * @date 2023/10/11
 */
@Service
public class VodServiceImpl implements VodService
{
    /**
     * 上传视频
     *
     * @param inputStream      输入流
     * @param originalFilename 原始文件名
     * @return videoId 视频 id
     */
    @Override
    public String uploadVideo(InputStream inputStream, String originalFilename)
    {
        try
        {
            // 指定当前腾讯云账号 id 和 密码
            VodUploadClient client = new VodUploadClient(ConstantPropertiesUtil.ACCESS_KEY_ID,
                    ConstantPropertiesUtil.ACCESS_KEY_SECRET);

            // 视频上传请求对象
            VodUploadRequest request = new VodUploadRequest();

            // 指定要上传的文件
            String path = LoaderClassPath.class.getResource("/video/Java 零基础入门.mp4").getPath();

            // 设置视频文件的本地路径
            request.setMediaFilePath(path);

            // 指定任务流
            request.setProcedure("LongVideoPreset");

            // 调用上传方法，传入接入点地域及上传请求
            VodUploadResponse response = client.upload("ap-beijing", request);

            // 返回文件 id 保存到业务表，用于控制视频播放
            String fileId = response.getFileId();
            System.out.println("fileId = " + fileId);

            return fileId;
        }
        catch (Exception e)
        {
            throw new SmartPlanetException(20001, "上传视频失败");
        }
    }

    /**
     * 删除视频
     *
     * @param videoSourceId 视频源 id
     */
    @Override
    public void removeVideo(String videoSourceId)
    {
        try
        {
            // 实例化一个认证对象，入参需要传入腾讯云账户 secretId，secretKey
            Credential cred = new Credential(ConstantPropertiesUtil.ACCESS_KEY_ID,
                    ConstantPropertiesUtil.ACCESS_KEY_SECRET);

            // 实例化要请求产品的 client 对象，clientProfile 是可选的
            VodClient client = new VodClient(cred, "ap-beijing");

            // 实例化一个请求对象，每个接口都会对应一个 request 对象
            DeleteMediaRequest req = new DeleteMediaRequest();
            req.setFileId(videoSourceId);

            // 返回的 resp 是一个 DeleteMediaResponse 的实例，与请求对象对应
            DeleteMediaResponse resp = client.DeleteMedia(req);

            // 输出 json 格式的字符串回包
            System.out.println("DeleteMediaResponse.toJsonString(resp) = " + DeleteMediaResponse.toJsonString(resp));
        }
        catch (TencentCloudSDKException e)
        {
            throw new SmartPlanetException(20001, "删除视频失败");

        }
    }
}
```

#### 4、完善上传视频功能

##### 4.1、定义接口

**创建 vod.js 定义接口。**

```javascript
import request from "@/utils/request";

const VOD_API = "/admin/vod";

export default {
  /**
   * 删除视频
   *
   * @param {number} id 视频源 id
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  removeByVodId(id) {
    return request({
      url: `${VOD_API}/remove/${id}`,
      method: "delete",
    });
  },
};
```

##### 4.1、添加上传视频

**（1）修改 video/form.vue 页面。**

![添加上传视频](https://img-blog.csdnimg.cn/8811cef9db0a4334bedc1301fa91cb5b.png)

```html
<template>
  <!-- 添加和修改课时表单 -->
  <el-dialog :visible="dialogVisible" title="添加课时" @close="close()">
    <el-form :model="video" label-width="120px">
      <el-form-item label="课时标题">
        <el-input v-model="video.title" />
      </el-form-item>
      <el-form-item label="课时排序">
        <el-input-number v-model="video.sort" :min="0" />
      </el-form-item>
      <el-form-item label="是否免费">
        <el-radio-group v-model="video.isFree">
          <el-radio :label="0">收费</el-radio>
          <el-radio :label="1">免费</el-radio>
        </el-radio-group>
      </el-form-item>

      <!-- 上传视频 -->
      <el-form-item label="上传视频">
        <el-upload
          ref="upload"
          action="#"
          :http-request="uploadVideo"
          :limit="1"
          :on-remove="handleRemove"
          :on-change="handleChange"
          :auto-upload="false"
        >
          <el-button
            :visible="!uploading"
            slot="trigger"
            size="small"
            type="primary"
            >选择视频</el-button
          >
          <el-button
            :visible="!uploading"
            style="margin-left: 40px"
            size="small"
            type="success"
            @click="submitUpload()"
            >点击上传</el-button
          >
          <el-progress
            class="progress"
            :text-inside="true"
            :stroke-width="18"
            :percentage="progress"
            status="exception"
          ></el-progress>
          <div slot="tip" class="el-upload__tip">
            只能上传 MP4 文件，且不超过 500MB
          </div>
        </el-upload>
      </el-form-item>
    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button :visible="!uploading" @click="close()">取 消</el-button>
      <el-button :visible="!uploading" type="primary" @click="saveOrUpdate()"
        >确 定</el-button
      >
    </div>
  </el-dialog>
</template>

<script>
  import TcVod from "vod-js-sdk-v6";
  import request from "@/utils/request";

  import videoAPI from "@/api/vod/video";
  // import vodAPI from "@/api/vod/vod";

  export default {
    data() {
      return {
        BASE_API: "http://localhost:8301",
        dialogVisible: false,
        uploading: false,

        video: {
          sort: 0,
          free: false,
        },

        // 上传文件列表
        fileList: [],

        // 进度条百分比
        progress: 0,

        // 图片原名称和 id
        filename: "",
        fileId: "",

        // 上传成功后的地址
        videoURL: "",
      };
    },

    methods: {
      open(chapterId, videoId) {
        this.dialogVisible = true;
        this.video.chapterId = chapterId;

        if (videoId) {
          videoAPI.getById(videoId).then((response) => {
            this.video = response.data;
            // 回显
            if (this.video.videoOriginalName) {
              this.fileList = [{ name: this.video.videoOriginalName }];
            }
          });
        }
      },

      close() {
        this.dialogVisible = false;

        // 重置表单
        this.resetForm();
      },

      resetForm() {
        this.video = {
          sort: 0,
          free: false,
        };

        // 重置视频上传列表
        this.fileList = [];
      },

      saveOrUpdate() {
        this.dialogVisible = true;

        if (!this.video.title) {
          this.$message.error("请输入课时标题");
          this.dialogVisible = false;

          return;
        }

        if (!this.video.id) {
          this.save();
        } else {
          this.update();
        }
      },

      save() {
        this.video.courseId = this.$parent.$parent.courseId;
        videoAPI.save(this.video).then((response) => {
          this.$message.success(response.message);
          // 关闭组件
          this.close();

          // 刷新列表
          this.$parent.fetchNodeList();
        });
      },

      update() {
        videoAPI.updateById(this.video).then((response) => {
          this.$message.success(response.message);
          // 关闭组件
          this.close();

          // 刷新列表
          this.$parent.fetchNodeList();
        });
      },

      // 处理上传超出一个视频
      handleUploadExceed(files, fileList) {
        this.$message.warning("想要重新上传视频，请先删除已上传的视频");
      },

      // 获取签名，这里的签名请求是由后端提供的，只需要拿到后端给的签名请求即可
      getVodSignature() {
        const url = this.BASE_API + "/admin/vod/sign";
        return request.get(url).then(function (response) {
          return response.data;
        });
      },

      // 文件列表改变时，将文件列表保存到本地
      handleChange(file, fileList) {
        this.fileList = fileList;
        this.filename = this.fileList[0].raw.name;
      },

      // 上传
      submitUpload() {
        if (this.fileList.length === 0) {
          this.$message.warning("请先选择视频，再进行上传");

          return;
        }

        if (this.uploading) {
          // 如果正在上传中，则直接返回，不执行上传逻辑
          return;
        }

        // 设置上传中状态
        this.uploading = true;

        this.uploadVideo();
      },

      // 自定义上传
      uploadVideo() {
        console.log(this.fileList[0].raw);

        if (this.fileList.length === 0) {
          window.alert("您还没有选取文件");
        } else {
          //必须以函数的形式返回，sdk 参数限制
          const getSignature = async () => {
            const data = await this.getVodSignature();

            return data;
          };

          const tcVod = new TcVod({
            // 获取上传签名的函数
            getSignature: getSignature,
          });

          // 获取通过 element-ui 上传到本地的文件，因为参数类型必须为 file，不能直接以对象的形式传输
          const mediaFile = this.fileList[0].raw;

          const uploader = tcVod.upload({
            mediaFile: mediaFile,
          });

          // 监听上传进度
          uploader.on("media_progress", (info) => {
            this.progress = parseInt(info.percent * 100);
          });

          // 上传结束时，将 url 存到本地
          uploader.done().then((doneResult) => {
            // 保存地址
            this.video.videoSourceId = doneResult.fileId;
            this.video.videoOriginalName = this.filename;

            // 将视频的第一帧保存为封面
            const canvas = document.createElement("canvas");
            const img = document.getElementById("video_img");
            const video = document.getElementById("video");
            video.setAttribute("crossOrigin", "anonymous");
            canvas.width = video.clientWidth;
            canvas.height = video.clientHeight;

            video.onloadeddata = (res) => {
              canvas
                .getContext("2d")
                .drawImage(video, 0, 0, canvas.width, canvas.height);
              const dataURL = canvas.toDataURL("image/png");
              img.setAttribute("src", dataURL);

              // 拿到 base64 的字符串，并保存到本地
              this.imgBase = dataURL.split(",")[1];
            };

            // 设置上传完成状态
            this.uploading = false;
          });
        }
      },

      // 点击删除时
      handleRemove(file, fileList) {
        console.log(file, fileList.length);
      },
    },
  };
</script>
```

#### 5、最终使用腾讯云客户端方式上传视频

##### 5.1、客户端上传视频

![客户端上传视频](https://img-blog.csdnimg.cn/3eb52ebc662542e3885623d54c5ae145.png)

##### 5.2、操作步骤一（申请上传签名）

###### 5.2.1、找到 Java 签名示例

![找到 Java 签名示例](https://img-blog.csdnimg.cn/01625a3101e6429f8281b3e76defdeab.png)

![找到 Java 签名示例](https://img-blog.csdnimg.cn/d899de91f276489fa7fec18674172d06.png)

###### 5.2.2、VodController 编写签名接口

**Signature 类。**

```java
package com.myxh.smart.planet.vod.utils;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * @author MYXH
 * @date 2023/10/11
 * @description 签名工具类
 */
public class Signature
{
    private String secretId;
    private String secretKey;
    private long currentTime;
    private int random;
    private int signValidDuration;

    private String procedure;

    // 签名算法
    private static final String HMAC_ALGORITHM = "HmacSHA1";
    private static final String CONTENT_CHARSET = "UTF-8";

    public static byte[] byteMerger(byte[] byte1, byte[] byte2)
    {
        byte[] byte3 = new byte[byte1.length + byte2.length];
        System.arraycopy(byte1, 0, byte3, 0, byte1.length);
        System.arraycopy(byte2, 0, byte3, byte1.length, byte2.length);

        return byte3;
    }

    // 获取签名
    public String getUploadSignature() throws Exception
    {
        String strSign = "";
        String contextStr = "";

        // 生成原始参数字符串
        long endTime = (currentTime + signValidDuration);
        contextStr += "secretId=" + java.net.URLEncoder.encode(secretId, StandardCharsets.UTF_8);
        contextStr += "&currentTimeStamp=" + currentTime;
        contextStr += "&expireTime=" + endTime;
        contextStr += "&random=" + random;

        // 设置转码任务流
        contextStr += "&procedure=" + procedure;

        try
        {
            Mac mac = Mac.getInstance(HMAC_ALGORITHM);
            SecretKeySpec secretKey = new SecretKeySpec(this.secretKey.getBytes(CONTENT_CHARSET), mac.getAlgorithm());
            mac.init(secretKey);

            byte[] hash = mac.doFinal(contextStr.getBytes(CONTENT_CHARSET));
            byte[] sigBuf = byteMerger(hash, contextStr.getBytes(StandardCharsets.UTF_8));
            strSign = base64Encode(sigBuf);
            strSign = strSign.replace(" ", "").replace("\n", "").replace("\r", "");
        }
        catch (Exception e)
        {
            throw e;
        }
        return strSign;
    }

    private String base64Encode(byte[] buffer)
    {
        Base64.Encoder encoder = Base64.getEncoder();

        return encoder.encodeToString(buffer);
    }

    public void setSecretId(String secretId)
    {
        this.secretId = secretId;
    }

    public void setSecretKey(String secretKey)
    {
        this.secretKey = secretKey;
    }

    public void setCurrentTime(long currentTime)
    {
        this.currentTime = currentTime;
    }

    public void setRandom(int random)
    {
        this.random = random;
    }

    public void setSignValidDuration(int signValidDuration)
    {
        this.signValidDuration = signValidDuration;
    }

    public void setProcedure(String procedure)
    {
        this.procedure = procedure;
    }
}
```

**VodController 类。**

```java
package com.myxh.smart.planet.vod.controller;

import com.myxh.smart.planet.exception.SmartPlanetException;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vod.service.VodService;
import com.myxh.smart.planet.vod.utils.ConstantPropertiesUtil;
import com.myxh.smart.planet.vod.utils.Signature;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Random;

/**
 * @author MYXH
 * @date 2023/10/11
 */
@Tag(name = "腾讯云点播接口", description = "腾讯云点播接口")
@RestController
@RequestMapping("/admin/vod")
@CrossOrigin
public class VodController
{
    @Autowired
    private VodService vodService;

    /**
     * 获取客户端上传视频签名
     *
     * @return signature 视频签名
     */
    @Operation(summary = "视频签名", description = "获取客户端上传视频签名")
    @GetMapping("sign")
    public Result<String> sign()
    {
        Signature sign = new Signature();

        // 设置 App 的云 API 密钥
        sign.setSecretId(ConstantPropertiesUtil.ACCESS_KEY_ID);
        sign.setSecretKey(ConstantPropertiesUtil.ACCESS_KEY_SECRET);
        sign.setCurrentTime(System.currentTimeMillis() / 1000);
        sign.setRandom(new Random().nextInt(java.lang.Integer.MAX_VALUE));

        // 签名有效期：2天
        sign.setSignValidDuration(3600 * 24 * 2);

        // 设置转码任务流
        sign.setProcedure("LongVideoPreset");

        try
        {
            String signature = sign.getUploadSignature();
            System.out.println("signature = " + signature);

            return Result.ok(signature);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            throw new SmartPlanetException(20001, "获取签名失败");
        }
    }
}
```

##### 5.3、操作步骤二（SDK 上传）

![操作步骤二（SDK 上传）](https://img-blog.csdnimg.cn/111362d610a34cb588805eb9917152c4.png)

###### 5.3.1、下载 Demo 源码修改

![下载 Demo 源码修改](https://img-blog.csdnimg.cn/ed58db4e049547618054c313bbe7848a.png)

###### 5.3.2、下载腾讯云 Web 端上传 SDK

```shell
npm install --save vod-js-sdk-v6
```

###### 5.3.3、video/form.vue 页面

```html
<template>
  <!-- 添加和修改课时表单 -->
  <el-dialog :visible="dialogVisible" title="添加课时" @close="close()">
    <el-form :model="video" label-width="120px">
      <el-form-item label="课时标题">
        <el-input v-model="video.title" />
      </el-form-item>
      <el-form-item label="课时排序">
        <el-input-number v-model="video.sort" :min="0" />
      </el-form-item>
      <el-form-item label="是否免费">
        <el-radio-group v-model="video.isFree">
          <el-radio :label="0">收费</el-radio>
          <el-radio :label="1">免费</el-radio>
        </el-radio-group>
      </el-form-item>

      <!-- 上传视频 -->
      <el-form-item label="上传视频">
        <el-upload
          ref="upload"
          action="#"
          :http-request="uploadVideo"
          :limit="1"
          :on-remove="handleRemove"
          :on-change="handleChange"
          :auto-upload="false"
        >
          <el-button
            :visible="!uploading"
            slot="trigger"
            size="small"
            type="primary"
            >选择视频</el-button
          >
          <el-button
            :visible="!uploading"
            style="margin-left: 40px"
            size="small"
            type="success"
            @click="submitUpload()"
            >点击上传</el-button
          >
          <el-progress
            class="progress"
            :text-inside="true"
            :stroke-width="18"
            :percentage="progress"
            status="exception"
          ></el-progress>
          <div slot="tip" class="el-upload__tip">
            只能上传 MP4 文件，且不超过 500MB
          </div>
        </el-upload>
      </el-form-item>
    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button :visible="!uploading" @click="close()">取 消</el-button>
      <el-button :visible="!uploading" type="primary" @click="saveOrUpdate()"
        >确 定</el-button
      >
    </div>
  </el-dialog>
</template>

<script>
  import TcVod from "vod-js-sdk-v6";
  import request from "@/utils/request";

  import videoAPI from "@/api/vod/video";
  // import vodAPI from "@/api/vod/vod";

  export default {
    data() {
      return {
        BASE_API: "http://localhost:8301",
        dialogVisible: false,
        uploading: false,

        video: {
          sort: 0,
          free: false,
        },

        // 上传文件列表
        fileList: [],

        // 进度条百分比
        progress: 0,

        // 图片原名称和 id
        filename: "",
        fileId: "",

        // 上传成功后的地址
        videoURL: "",
      };
    },

    methods: {
      open(chapterId, videoId) {
        this.dialogVisible = true;
        this.video.chapterId = chapterId;

        if (videoId) {
          videoAPI.getById(videoId).then((response) => {
            this.video = response.data;
            // 回显
            if (this.video.videoOriginalName) {
              this.fileList = [{ name: this.video.videoOriginalName }];
            }
          });
        }
      },

      close() {
        this.dialogVisible = false;

        // 重置表单
        this.resetForm();
      },

      resetForm() {
        this.video = {
          sort: 0,
          free: false,
        };

        // 重置视频上传列表
        this.fileList = [];
      },

      saveOrUpdate() {
        this.dialogVisible = true;

        if (!this.video.title) {
          this.$message.error("请输入课时标题");
          this.dialogVisible = false;

          return;
        }

        if (!this.video.id) {
          this.save();
        } else {
          this.update();
        }
      },

      save() {
        this.video.courseId = this.$parent.$parent.courseId;
        videoAPI.save(this.video).then((response) => {
          this.$message.success(response.message);
          // 关闭组件
          this.close();

          // 刷新列表
          this.$parent.fetchNodeList();
        });
      },

      update() {
        videoAPI.updateById(this.video).then((response) => {
          this.$message.success(response.message);
          // 关闭组件
          this.close();

          // 刷新列表
          this.$parent.fetchNodeList();
        });
      },

      // 处理上传超出一个视频
      handleUploadExceed(files, fileList) {
        this.$message.warning("想要重新上传视频，请先删除已上传的视频");
      },

      // 获取签名，这里的签名请求是由后端提供的，只需要拿到后端给的签名请求即可
      getVodSignature() {
        const url = this.BASE_API + "/admin/vod/sign";
        return request.get(url).then(function (response) {
          return response.data;
        });
      },

      // 文件列表改变时，将文件列表保存到本地
      handleChange(file, fileList) {
        this.fileList = fileList;
        this.filename = this.fileList[0].raw.name;
      },

      // 上传
      submitUpload() {
        if (this.fileList.length === 0) {
          this.$message.warning("请先选择视频，再进行上传");

          return;
        }

        if (this.uploading) {
          // 如果正在上传中，则直接返回，不执行上传逻辑
          return;
        }

        // 设置上传中状态
        this.uploading = true;

        this.uploadVideo();
      },

      // 自定义上传
      uploadVideo() {
        console.log(this.fileList[0].raw);

        if (this.fileList.length === 0) {
          window.alert("您还没有选取文件");
        } else {
          //必须以函数的形式返回，sdk 参数限制
          const getSignature = async () => {
            const data = await this.getVodSignature();

            return data;
          };

          const tcVod = new TcVod({
            // 获取上传签名的函数
            getSignature: getSignature,
          });

          // 获取通过 element-ui 上传到本地的文件，因为参数类型必须为 file，不能直接以对象的形式传输
          const mediaFile = this.fileList[0].raw;

          const uploader = tcVod.upload({
            mediaFile: mediaFile,
          });

          // 监听上传进度
          uploader.on("media_progress", (info) => {
            this.progress = parseInt(info.percent * 100);
          });

          // 上传结束时，将 url 存到本地
          uploader.done().then((doneResult) => {
            // 保存地址
            this.video.videoSourceId = doneResult.fileId;
            this.video.videoOriginalName = this.filename;

            // 将视频的第一帧保存为封面
            const canvas = document.createElement("canvas");
            const img = document.getElementById("video_img");
            const video = document.getElementById("video");
            video.setAttribute("crossOrigin", "anonymous");
            canvas.width = video.clientWidth;
            canvas.height = video.clientHeight;

            video.onloadeddata = (res) => {
              canvas
                .getContext("2d")
                .drawImage(video, 0, 0, canvas.width, canvas.height);
              const dataURL = canvas.toDataURL("image/png");
              img.setAttribute("src", dataURL);

              // 拿到 base64 的字符串，并保存到本地
              this.imgBase = dataURL.split(",")[1];
            };

            // 设置上传完成状态
            this.uploading = false;
          });
        }
      },

      // 点击删除时
      handleRemove(file, fileList) {
        console.log(file, fileList.length);
      },
    },
  };
</script>
```

#### 6、完善删除视频功能

##### 6.1、修改 VideoController 方法

```java
package com.myxh.smart.planet.vod.controller;

import com.myxh.smart.planet.model.vod.Video;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vod.service.VideoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author MYXH
 * @date 2023/10/8
 *
 * <p>
 * 课程视频 前端控制器
 * </p>
 */
@Tag(name = "课程视频小节接口", description = "课程视频小节管理接口")
@RestController
@RequestMapping("/admin/vod/video")
@CrossOrigin
public class VideoController
{
    @Autowired
    private VideoService videoService;

    /**
     * 获取课程视频小节
     *
     * @param id 课程视频小节 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "获取课程视频小节", description = "获取课程视频小节")
    @GetMapping("get/{id}")
    public Result<Video> get(@Parameter(name = "id", description = "课程视频小节ID", required = true)
                             @PathVariable("id") Long id)
    {
        Video video = videoService.getById(id);

        return Result.ok(video);
    }

    /**
     * 新增课程视频小节
     *
     * @param video 课程视频小节数据
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "新增课程视频小节", description = "新增课程视频小节")
    @PostMapping("save")
    public Result<Void> save(@RequestBody Video video)
    {
        videoService.save(video);

        return Result.ok(null);
    }

    /**
     * 修改课程视频小节
     *
     * @param video 课程视频小节数据
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "修改课程视频小节", description = "修改课程视频小节")
    @PostMapping("update")
    public Result<Void> update(@RequestBody Video video)
    {
        videoService.updateVideoById(video);

        return Result.ok(null);
    }

    /**
     * 删除课程视频小节
     *
     * @param id 课程视频小节 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除课程视频小节", description = "删除课程视频小节")
    @DeleteMapping("remove/{id}")
    public Result<Void> remove(@Parameter(name = "id", description = "课程视频小节ID", required = true)
                               @PathVariable("id") Long id)
    {
        videoService.removeVideoById(id);

        return Result.ok(null);
    }
}
```

##### 6.2、修改 VideoService 方法

**修改 VideoService 和 VideoServiceImpl。**

```java
package com.myxh.smart.planet.vod.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.vod.Video;
import com.myxh.smart.planet.vod.mapper.VideoMapper;
import com.myxh.smart.planet.vod.service.VideoService;
import com.myxh.smart.planet.vod.service.VodService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/8
 *
 * <p>
 * 课程视频 服务实现类
 * </p>
 */
@Service
public class VideoServiceImpl extends ServiceImpl<VideoMapper, Video> implements VideoService
{
    // 注入 VodService
    @Autowired
    private VodService vodService;

    /**
     * 根据课程 id，删除课程视频小节，同时删除视频
     *
     * @param id 课程 id
     */
    @Override
    public void removeVideoByCourseId(Long id)
    {
        // 1、根据课程 id，删除小节中的视频
        // 获取课程里面所有小节
        QueryWrapper<Video> wrapper = new QueryWrapper<>();
        wrapper.eq("course_id", id);
        List<Video> videoList = baseMapper.selectList(wrapper);

        // 遍历获取每个小节中的视频源 id
        for (Video video : videoList)
        {
            String videoSourceId = video.getVideoSourceId();

            // 如果视频源 id 不为空，调用方法删除
            if (!ObjectUtils.isEmpty(videoSourceId))
            {
                vodService.removeVideo(videoSourceId);
            }
        }

        // 2、根据课程 id，删除小节
        baseMapper.delete(wrapper);
    }

    /**
     * 根据章节 id，删除课程视频小节，同时删除视频
     *
     * @param id 章节 id
     */
    public void removeVideoByChapterId(Long id)
    {
        // 1、根据章节 id，删除小节中的视频
        // 获取章节里的所有小节
        QueryWrapper<Video> wrapper = new QueryWrapper<>();
        wrapper.eq("chapter_id", id);
        List<Video> videoList = baseMapper.selectList(wrapper);

        // 遍历获取每个小节中的视频源 id
        for (Video video : videoList)
        {
            String videoSourceId = video.getVideoSourceId();

            // 如果视频源 id 不为空，调用方法删除
            if (!ObjectUtils.isEmpty(videoSourceId))
            {
                vodService.removeVideo(videoSourceId);
            }
        }

        // 2、根据课程 id，删除小节
        baseMapper.delete(wrapper);
    }

    /**
     * 根据课程视频小节 id，删除课程视频小节，同时删除视频
     *
     * @param id 课程视频小节 id
     */
    @Override
    public void removeVideoById(Long id)
    {
        // 1、根据课程视频小节 id，删除视频
        // 获取课程视频小节
        Video video = baseMapper.selectById(id);

        // 获取视频源 id
        String videoSourceId = video.getVideoSourceId();

        // 如果视频源 id 不为空，调用方法删除
        if (!ObjectUtils.isEmpty(videoSourceId))
        {
            vodService.removeVideo(videoSourceId);
        }

        // 2、根据课程视频小节 id，删除小节
        baseMapper.deleteById(id);
    }

    /**
     * 根据课程视频小节 id，修改课程视频小节
     *
     * @param video 课程视频小节数据
     */
    @Override
    public void updateVideoById(Video video)
    {
        Video oldVideo = baseMapper.selectById(video.getId());

        // 如果新的视频源 id 与旧的不相等
        if (!ObjectUtils.isEmpty(oldVideo.getVideoSourceId()) && !oldVideo.getVideoSourceId().equals(video.getVideoSourceId()))
        {
            // 先删除旧视频
            vodService.removeVideo(oldVideo.getVideoSourceId());
        }

        // 再更新课程视频小节
        baseMapper.updateById(video);
    }
}
```

##### 6.3 修改 ChapterController 方法

```java
package com.myxh.smart.planet.vod.controller;

import com.myxh.smart.planet.model.vod.Chapter;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vo.vod.ChapterVo;
import com.myxh.smart.planet.vod.service.ChapterService;
import com.myxh.smart.planet.vod.service.VideoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.DeleteMapping;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/8
 *
 * <p>
 * 章节 前端控制器
 * </p>
 */
@Tag(name = "章节接口", description = "章节管理接口")
@RestController
@RequestMapping("/admin/vod/chapter")
@CrossOrigin
public class ChapterController
{
    @Autowired
    private ChapterService chapterService;

    @Autowired
    private VideoService videoService;

    /**
     * 大纲列表，获取章节和小节列表
     *
     * @param courseId 课程 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "大纲列表", description = "获取获取章节和小节列表")
    @GetMapping("get/nested/tree/list/{courseId}")
    public Result<List<ChapterVo>> getNestedTreeList(@Parameter(name = "courseId", description = "课程ID", required = true)
                                                     @PathVariable("courseId") Long courseId)
    {
        List<ChapterVo> chapterVoList = chapterService.getNestedTreeList(courseId);

        return Result.ok(chapterVoList);
    }

    /**
     * 添加章节
     *
     * @param chapter 章节数据
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "添加章节", description = "添加章节")
    @PostMapping("save")
    public Result<Void> saveChapter(@RequestBody Chapter chapter)
    {
        chapterService.save(chapter);

        return Result.ok(null);
    }

    /**
     * 根据 id 查询章节
     *
     * @param id 章节 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "查询章节", description = "根据 id 查询章节")
    @GetMapping("get/{id}")
    public Result<Chapter> getChapter(@Parameter(name = "id", description = "章节ID", required = true)
                                      @PathVariable("id") Long id)
    {
        Chapter chapter = chapterService.getById(id);

        return Result.ok(chapter);
    }

    /**
     * 修改章节
     *
     * @param chapter 章节数据
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "修改章节", description = "修改章节")
    @PostMapping("update")
    public Result<Void> updateChapter(@RequestBody Chapter chapter)
    {
        chapterService.updateById(chapter);

        return Result.ok(null);
    }

    /**
     * 根据 id 删除章节
     *
     * @param id 章节 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除章节", description = "根据 id 删除章节")
    @DeleteMapping("remove/{id}")
    public Result<Void> removeChapter(@Parameter(name = "id", description = "章节ID", required = true)
                                      @PathVariable("id") Long id)
    {
        // 1、根据章节 id，删除课程视频小节，同时删除视频
        videoService.removeVideoByChapterId(id);

        // 2、根据 id，删除章节
        chapterService.removeById(id);

        return Result.ok(null);
    }
}
```

##### 6.4 修改 ChapterService 方法

**修改 ChapterService 和 ChapterServiceImpl。**

```java
package com.myxh.smart.planet.vod.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.vod.Chapter;
import com.myxh.smart.planet.model.vod.Video;
import com.myxh.smart.planet.vo.vod.ChapterVo;
import com.myxh.smart.planet.vo.vod.VideoVo;
import com.myxh.smart.planet.vod.mapper.ChapterMapper;
import com.myxh.smart.planet.vod.service.ChapterService;
import com.myxh.smart.planet.vod.service.VideoService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/8
 *
 * <p>
 * 章节 服务实现类
 * </p>
 */
@Service
public class ChapterServiceImpl extends ServiceImpl<ChapterMapper, Chapter> implements ChapterService
{
    @Autowired
    private VideoService videoService;

    /**
     * 大纲列表，获取章节和小节列表
     *
     * @param courseId 课程 id
     * @return chapterVoList 章节和小节列表
     */
    @Override
    public List<ChapterVo> getNestedTreeList(Long courseId)
    {
        // 定义章节和小节列表 List 集合
        List<ChapterVo> chapterVoList = new ArrayList<>();

        // 根据 courseId 获取课程里面所有章节
        QueryWrapper<Chapter> chapterQueryWrapper = new QueryWrapper<>();
        chapterQueryWrapper.eq("course_id", courseId);
        List<Chapter> chapterList = baseMapper.selectList(chapterQueryWrapper);

        // 根据 courseId 获取课程里面所有小节
        LambdaQueryWrapper<Video> videoLambdaQueryWrapper = new LambdaQueryWrapper<>();
        videoLambdaQueryWrapper.eq(Video::getCourseId, courseId);
        videoLambdaQueryWrapper.orderByAsc(Video::getSort, Video::getId);
        List<Video> videoList = videoService.list(videoLambdaQueryWrapper);

        // 封装章节
        // 遍历所有的章节
        for (Chapter chapter : chapterList)
        {
            // 创建 ChapterVo 对象
            ChapterVo chapterVo = new ChapterVo();
            BeanUtils.copyProperties(chapter, chapterVo);
            chapterVoList.add(chapterVo);

            // 封装章节里面的小节
            // 创建 List 集合用来封装章节所有小节
            List<VideoVo> videoVoList = new ArrayList<>();

            // 遍历小节 List
            for (Video video : videoList)
            {
                // 判断小节是哪个章节下面
                if (chapter.getId().equals(video.getChapterId()))
                {
                    VideoVo videoVo = new VideoVo();
                    BeanUtils.copyProperties(video, videoVo);
                    videoVoList.add(videoVo);
                }
            }

            // 把章节里面所有小节集合放到每个章节里面
            chapterVo.setChildren(videoVoList);
        }

        return chapterVoList;
    }

    /**
     * 根据课程 id 删除章节
     *
     * @param id 课程 id
     */
    @Override
    public void removeChapterByCourseId(Long id)
    {
        QueryWrapper<Chapter> wrapper = new QueryWrapper<>();
        wrapper.eq("course_id", id);
        baseMapper.delete(wrapper);
    }
}
```

##### 6.5 修改 CourseController 方法

```java
package com.myxh.smart.planet.vod.controller;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.myxh.smart.planet.model.vod.Course;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vo.vod.CourseFormVo;
import com.myxh.smart.planet.vo.vod.CoursePublishVo;
import com.myxh.smart.planet.vo.vod.CourseQueryVo;
import com.myxh.smart.planet.vod.service.CourseService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.DeleteMapping;

import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/8
 *
 * <p>
 * 课程 前端控制器
 * </p>
 */
@Tag(name = "课程接口", description = "课程管理接口")
@RestController
@RequestMapping("/admin/vod/course")
@CrossOrigin
public class CourseController
{
    @Autowired
    private CourseService courseService;

    /**
     * 点播课程列表
     *
     * @param current       当前页码
     * @param limit         每页记录数
     * @param courseQueryVo 查询对象
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "获取点播课程", description = "获取点播课程列表")
    @GetMapping("find/query/page/{current}/{limit}")
    public Result<Map<String, Object>> courseList(@Parameter(name = "current", description = "当前页码", required = true) @PathVariable("current") Long current,
                                                  @Parameter(name = "limit", description = "每页记录数", required = true) @PathVariable("limit") Long limit,
                                                  @Parameter(name = "courseQueryVo", description = "查询对象") CourseQueryVo courseQueryVo)
    {
        Page<Course> coursePageParam = new Page<>(current, limit);
        Map<String, Object> coursePage = courseService.findPage(coursePageParam, courseQueryVo);

        return Result.ok(coursePage);
    }

    /**
     * 添加课程基本信息
     *
     * @param courseFormVo 课程基本信息
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "添加课程基本信息", description = "添加课程基本信息")
    @PostMapping("save")
    public Result<Long> saveCourseInfo(@RequestBody CourseFormVo courseFormVo)
    {
        Long courseId = courseService.saveCourseInfo(courseFormVo);

        return Result.ok(courseId);
    }

    /**
     * 根据 id 获取课程信息
     *
     * @param id 课程 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "根据 id 获取课程信息", description = "根据 id 获取课程信息")
    @GetMapping("get/{id}")
    public Result<CourseFormVo> get(@PathVariable("id") Long id)
    {
        CourseFormVo courseFormVo = courseService.getCourseInfoById(id);

        return Result.ok(courseFormVo);
    }

    /**
     * 根据 id 修改课程信息
     *
     * @param courseFormVo 课程基本信息
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "根据 id 修改课程信息", description = "根据 id 修改课程信息")
    @PostMapping("update")
    public Result<Long> updateCourse(@RequestBody CourseFormVo courseFormVo)
    {
        Long courseId = courseService.updateCourseById(courseFormVo);

        return Result.ok(courseId);
    }

    /**
     * 根据课程 id 查询课程发布信息
     *
     * @param id 课程 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "根据课程 id 查询课程发布信息", description = "根据课程 id 查询课程发布信息")
    @GetMapping("get/course/publish/vo/{id}")
    public Result<CoursePublishVo> getCoursePublishVoById(@Parameter(name = "id", description = "课程ID", required = true)
                                                          @PathVariable Long id)
    {
        CoursePublishVo coursePublishVo = courseService.getCoursePublishVo(id);

        return Result.ok(coursePublishVo);
    }

    /**
     * 根据课程 id 最终发布课程
     *
     * @param id 课程 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "根据课程 id 最终发布课程", description = "根据课程 id 最终发布课程")
    @PutMapping("publish/course/{id}")
    public Result<Void> publishCourseById(@Parameter(name = "id", description = "课程ID", required = true)
                                          @PathVariable Long id)
    {
        courseService.publishCourse(id);

        return Result.ok(null);
    }

    /**
     * 删除课程
     *
     * @param id 课程 id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除课程", description = "删除课程")
    @DeleteMapping("remove/{id}")
    public Result<Void> remove(@Parameter(name = "id", description = "课程ID", required = true)
                               @PathVariable Long id)
    {
        courseService.removeCourseById(id);

        return Result.ok(null);
    }
}
```

##### 6.6 修改 CourseService 方法

**修改 CourseService 和 CourseServiceImpl。**

```java
package com.myxh.smart.planet.vod.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.vod.Course;
import com.myxh.smart.planet.model.vod.CourseDescription;
import com.myxh.smart.planet.model.vod.Subject;
import com.myxh.smart.planet.model.vod.Teacher;
import com.myxh.smart.planet.vo.vod.CourseFormVo;
import com.myxh.smart.planet.vo.vod.CoursePublishVo;
import com.myxh.smart.planet.vo.vod.CourseQueryVo;
import com.myxh.smart.planet.vod.mapper.CourseMapper;
import com.myxh.smart.planet.vod.service.*;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/8
 *
 * <p>
 * 课程 服务实现类
 * </p>
 */
@Service
public class CourseServiceImpl extends ServiceImpl<CourseMapper, Course> implements CourseService
{
    @Autowired
    private SubjectService subjectService;

    @Autowired
    private TeacherService teacherService;

    @Autowired
    private CourseDescriptionService courseDescriptionService;

    @Autowired
    private ChapterService chapterService;

    @Autowired
    private VideoService videoService;

    /**
     * 点播课程列表
     *
     * @param coursePageParam 课程页面参数
     * @param courseQueryVo   查询对象
     * @return coursePage 课程页面
     */
    @Override
    public Map<String, Object> findPage(Page<Course> coursePageParam, CourseQueryVo courseQueryVo)
    {
        // 获取条件值
        // 名称
        String title = courseQueryVo.getTitle();

        // 二级分类
        Long subjectId = courseQueryVo.getSubjectId();

        // 一级分类
        Long subjectParentId = courseQueryVo.getSubjectParentId();

        // 教师
        Long teacherId = courseQueryVo.getTeacherId();

        // 封装条件
        QueryWrapper<Course> wrapper = new QueryWrapper<>();

        if (StringUtils.hasLength(title))
        {
            wrapper.like("title", title);
        }
        if (!ObjectUtils.isEmpty(subjectId))
        {
            wrapper.eq("subject_id", subjectId);
        }
        if (!ObjectUtils.isEmpty(subjectParentId))
        {
            wrapper.eq("subject_parent_id", subjectParentId);
        }
        if (!ObjectUtils.isEmpty(teacherId))
        {
            wrapper.eq("teacher_id", teacherId);
        }

        // 调用方法实现条件查询分页
        Page<Course> coursePage = baseMapper.selectPage(coursePageParam, wrapper);

        // 总记录数
        Long totalCount = coursePage.getTotal();

        // 总页数
        Long totalPage = coursePage.getPages();

        // 每页数据集合
        List<Course> coursePageRecords = coursePage.getRecords();

        // 遍历封装教师和分类名称，获取 id 对应名称，进行封装，最终显示
        coursePageRecords.stream().forEach(this::getTeacherOrSubjectName);

        // 封装返回数据
        Map<String, Object> coursePageMap = new HashMap<>();
        coursePageMap.put("totalCount", totalCount);
        coursePageMap.put("totalPage", totalPage);
        coursePageMap.put("records", coursePageRecords);

        return coursePageMap;
    }

    /**
     * 获取教师和分类名称
     *
     * @param course 课程数据
     * @return course 课程数据
     */
    private Course getTeacherOrSubjectName(Course course)
    {
        // 根据教师 id 获取教师名称
        Teacher teacher = teacherService.getById(course.getTeacherId());

        if (teacher != null)
        {
            course.getParam().put("teacherName", teacher.getName());
        }

        // 根据课程分类 id 获取课程分类名称
        Subject subjectOne = subjectService.getById(course.getSubjectParentId());

        if (subjectOne != null)
        {
            course.getParam().put("subjectParentTitle", subjectOne.getTitle());
        }

        Subject subjectTwo = subjectService.getById(course.getSubjectId());

        if (subjectTwo != null)
        {
            course.getParam().put("subjectTitle", subjectTwo.getTitle());
        }

        return course;
    }

    /**
     * 添加课程基本信息
     *
     * @param courseFormVo 课程基本信息
     * @return courseId 课程 id
     */
    @Override
    public Long saveCourseInfo(CourseFormVo courseFormVo)
    {
        // 添加课程基本信息，操作 course 表
        Course course = new Course();
        BeanUtils.copyProperties(courseFormVo, course);
        baseMapper.insert(course);

        // 添加课程详情信息，操作 course_description 表
        CourseDescription courseDescription = new CourseDescription();
        courseDescription.setDescription(courseFormVo.getDescription());

        // 设置课程 id
        courseDescription.setCourseId(course.getId());
        courseDescriptionService.save(courseDescription);

        // 返回课程 id
        return course.getId();
    }

    /**
     * 根据 id 获取课程信息
     *
     * @param id 课程 id
     * @return CourseFormVo 课程基本信息
     */
    @Override
    public CourseFormVo getCourseInfoById(Long id)
    {
        // 从 course 表中获取课程基本信息
        Course course = baseMapper.selectById(id);

        if (course == null)
        {
            return null;
        }

        //从 course_description 表中获取课程描述信息
        QueryWrapper<CourseDescription> wrapper = new QueryWrapper<>();
        wrapper.eq("course_id", id);
        CourseDescription courseDescription = courseDescriptionService.getOne(wrapper);

        // 封装描述信息，创建 CourseFormVo 对象
        CourseFormVo courseFormVo = new CourseFormVo();
        BeanUtils.copyProperties(course, courseFormVo);

        if (courseDescription != null)
        {
            courseFormVo.setDescription(courseDescription.getDescription());
        }

        return courseFormVo;
    }

    /**
     * 根据 id 修改课程信息
     *
     * @param courseFormVo 课程基本信息
     * @return courseId 课程 id
     */
    @Override
    public Long updateCourseById(CourseFormVo courseFormVo)
    {
        // 修改课程基本信息
        Course course = new Course();
        BeanUtils.copyProperties(courseFormVo, course);
        baseMapper.updateById(course);

        // 修改课程详情信息
        QueryWrapper<CourseDescription> wrapper = new QueryWrapper<>();
        wrapper.eq("course_id", course.getId());
        CourseDescription courseDescription = courseDescriptionService.getOne(wrapper);
        courseDescription.setDescription(courseFormVo.getDescription());

        // 设置课程描述 id
        courseDescription.setCourseId(course.getId());
        courseDescriptionService.updateById(courseDescription);

        // 返回课程 id
        return course.getId();
    }

    /**
     * 根据课程 id 查询课程发布信息
     *
     * @param id 课程 id
     * @return coursePublishVo 课程发布信息
     */
    @Override
    public CoursePublishVo getCoursePublishVo(Long id)
    {
        return baseMapper.selectCoursePublishVoById(id);
    }

    /**
     * 根据课程 id 最终发布课程
     *
     * @param id 课程 id
     */
    @Override
    public void publishCourse(Long id)
    {
        Course course = baseMapper.selectById(id);

        // 已经发布课程
        course.setStatus(1);
        course.setPublishTime(new Date());
        baseMapper.updateById(course);
    }

    /**
     * 删除课程
     *
     * @param id 课程 id
     */
    @Override
    public void removeCourseById(Long id)
    {
        // 根据课程 id 删除小节
        videoService.removeVideoByCourseId(id);

        // 根据课程 id 删除章节
        chapterService.removeChapterByCourseId(id);

        // 根据课程 id 删除描述
        courseDescriptionService.removeByCourseId(id);

        // 根据课程 id 删除课程
        baseMapper.deleteById(id);
    }
}
```

## Day 10-整合网关与实现订单和营销管理模块

### 一、Spring Cloud 相关概念

#### 1、基本概念

##### 1.1、什么是 Spring Cloud

Spring Cloud 是一系列框架的集合。它利用 Spring Boot 的开发便利性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、 熔断器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 SpringBoot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

##### 1.2、Spring Cloud 和 Spring Boot 关系

Spring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个微服务，Spring Cloud 是一个基于 Spring Boot 实现的开发工具；Spring Boot 专注于快速、方便集成的单个微服务个体，Spring Cloud 关注全局的服务治理框架； Spring Boot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud 很大的一部分是基于 Spring Boot 来实现，必须基于 Spring Boot 开发。可以单独使用 Spring Boot 开发项目，但是 Spring Cloud 离不开 Spring Boot。

#### 2、Spring Cloud 相关基础服务组件

服务发现——Netflix Eureka （Nacos）。

服务调用——Netflix Feign。

熔断器——Netflix Hystrix。

服务网关——Spring Cloud GateWay。

分布式配置——Spring Cloud Config （Nacos）。

消息总线 —— Spring Cloud Bus （Nacos）。

### 二、搭建 Nacos 服务

#### 1、Nacos 概述

##### 1.1、基本概念

​Nacos 是阿里巴巴推出来的一个新开源项目，是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。

##### 1.2、常见的注册中心

（1）Eureka（原生，2.0 遇到性能瓶颈，停止维护）。

（2）Zookeeper（支持，专业的独立产品。例如：dubbo）。

（3）Consul（原生，GO 语言开发）。

（4） Nacos。

- 相对于 Spring Cloud Eureka 来说，Nacos 更强大。Nacos = Spring Cloud Eureka + Spring Cloud Config。

- Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。

##### 1.3、Nacos 结构图

![Nacos 结构图](https://img-blog.csdnimg.cn/3ceb715248c245598e7ca673fa6df66c.png)

#### 2、Nacos 下载和安装

##### 2.1、下载地址和版本

下载地址：https://github.com/alibaba/nacos/releases

下载版本：nacos-server-2.2.3.tar.gz 或 nacos-server-2.2.3.zip，解压任意目录即可。

##### 2.2、启动 nacos 服务

**（1） Linux/Unix/Mac**

启动命令(standalone 代表着单机模式运行，非集群模式)。

启动命令：sh startup.sh -m standalone

**（2）Windows**

启动方式，cmd 打开，执行命令： startup.cmd -m standalone

访问：http://localhost:8848/nacos

用户名/密码：nacos/nacos

**（3）登录界面。**

![登录界面](https://img-blog.csdnimg.cn/c93fa06650d7458e9222f6a4add8be1b.png)

**（4）主界面。**

![主界面](https://img-blog.csdnimg.cn/38388629cc514088bdd35a399b578be2.png)

#### 3、服务注册

把 service-vod 微服务注册到注册中心，其他模块注册步骤相同。

##### 3.1、在 service 模块配置 pom

配置 Nacos 客户端的 pom 依赖。

```xml
<!-- alibaba-nacos-discovery 服务注册 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>

<!-- openfeign 服务调用 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

<!-- alibaba-sentinel 流量控制 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

##### 3.2、配置 service-vod

配置 application.properties，在客户端微服务中添加注册 Nacos 服务的配置信息。

```properties
# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

##### 3.3、添加 Nacos 客户端注解

在 service-vod 微服务启动类中添加注解。

```java
package com.myxh.smart.planet.vod;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.ComponentScan;

/**
 * @author MYXH
 * @date 2023/9/29
 */
@SpringBootApplication
@ComponentScan("com.myxh.smart.planet")
@EnableDiscoveryClient
public class ServiceVodApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceVodApplication.class, args);
    }
}
```

##### 3.4、启动客户端微服务

启动注册中心。

启动已注册的微服务，可以在 Nacos 服务列表中看到被注册的微服务。

![启动客户端微服务](https://img-blog.csdnimg.cn/b920525b4729496eb505e58adc5409a7.png)

### 三、整合 Spring Cloud GateWay 网关

#### 1、网关基本概念

##### 1.1、Gateway 概述

**Spring cloud gateway**是 spring 官方基于 Spring 5.0、Spring Boot2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供简单、有效和统一的 API 路由管理方式，Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且还基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。

![Gateway 概述](https://img-blog.csdnimg.cn/8a5e3db2ada549c285135f28a6461763.png)

##### 1.2、Gateway 核心概念

网关提供 API 全托管服务，丰富的 API 管理功能，辅助企业管理大规模的 API，以降低管理成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等贡呢。一般来说网关对外暴露的 URL 或者接口信息，统称为路由信息。如果研发过网关中间件或者使用过 Zuul 的人，会知道网关的核心是 Filter 以及 Filter Chain（Filter 责任链）。Sprig Cloud Gateway 也具有路由和 Filter 的概念。下面介绍一下 Spring Cloud Gateway 中几个重要的概念。

**（1）路由：** 路由是网关最基础的部分，路由信息有一个 ID、一个目的 URL、一组断言和一组 Filter 组成。如果断言路由为真，则说明请求的 URL 和配置匹配。

**（2）断言：** Java8 中的断言函数。Spring Cloud Gateway 中的断言函数输入类型是 Spring5.0 框架中的 ServerWebExchange。Spring Cloud Gateway 中的断言函数允许开发者去定义匹配来自于 http request 中的任何信息，比如请求头和参数等。

**（3）过滤器：** 一个标准的 Spring webFilter。Spring cloud gateway 中的 filter 分为两种类型的 Filter，分别是 Gateway Filter 和 Global Filter。过滤器 Filter 将会对请求和响应进行修改处理。

![Gateway 核心概念](https://img-blog.csdnimg.cn/d5cd5ca09e59416d8f9396ad41cae2f7.png)

如图所示，Spring cloud Gateway 发出请求。然后再由 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway web handler。Handler 再通过指定的过滤器链将请求发送到实际的服务执行业务逻辑，然后返回。

#### 2、实现网关转发功能

##### 2.1、创建网关模块

**（1）在 SmartPlanet 下创建 service-gateway。**

![创建网关模块](https://img-blog.csdnimg.cn/20eb84d20c7b4193ad9f334b88ef5736.png)

##### 2.2、引入网关依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.myxh.smart.planet</groupId>
        <artifactId>SmartPlanet</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>service-gateway</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- service-utils -->
        <dependency>
            <groupId>com.myxh.smart.planet</groupId>
            <artifactId>service-utils</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>

        <!-- alibaba-nacos-discovery 服务注册 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>

        <!-- gateway 网关 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!-- 负载平衡 loadbalancer -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>
    </dependencies>
</project>
```

##### 2.3、创建启动类

```java
package com.myxh.smart.planet.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

/**
 * @author MYXH
 * @date 2023/10/14
 */
@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```

##### 2.4、配置路由规则

**（1）编写 application.properties。**

```properties
# 服务端口
server.port=8333

# 服务名
spring.application.name=service-gateway

# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

# 使用服务发现路由
spring.cloud.gateway.discovery.locator.enabled=true

# service-vod 模块配置
# 设置路由 id
spring.cloud.gateway.routes[0].id=service-vod
# 设置路由的 uri，lb 全称为 Load Balance 负载平衡
spring.cloud.gateway.routes[0].uri=lb://service-vod
# 设置路由断言,代理 servicerId 为 auth-service 的 /auth/ 路径，/admin/vod/teacher
spring.cloud.gateway.routes[0].predicates= Path=/*/vod/**
```

#### 3、网关解决跨域问题

##### 3.1、跨域概述

跨域本质是浏览器对于 ajax 请求的一种安全限制：一个页面发起的 ajax 请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。因此：跨域问题 是针对 ajax 的一种限制。但是这却给开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同。

之前通过服务器添加注解实现，现在跨域通过网关来解决跨域问题。

##### 3.2、创建配置类

![创建配置类](https://img-blog.csdnimg.cn/f90c0701dd1441e9b02423b4770760dc.png)

```java
package com.myxh.smart.planet.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.web.util.pattern.PathPatternParser;

/**
 * @author MYXH
 * @date 2023/10/14
 */
@Configuration
public class CorsConfig
{
    /**
     * 处理跨域
     *
     * @return CorsWebFilter(source) 核心 Web 过滤器
     */
    @Bean
    public CorsWebFilter corsFilter()
    {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod("*");
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}
```

**注意：** 目前已经在网关做了跨域处理，那么 service 服务就不需要再做跨域处理了，将之前在 controller 类上添加过@CrossOrigin 标签的去掉。

#### 4、修改前端配置文件

##### 4.1、修改接口为网关地址

![修改接口为网关地址](https://img-blog.csdnimg.cn/cc9aed6bcdba411088a7411aee783249.png)

### 四、后台管理系统-订单管理模块

#### 1、环境准备

##### 1.1、创建数据库表

![创建数据库表](https://img-blog.csdnimg.cn/5f8377774e264ecfa11abb7b314c4219.png)

##### 1.2、创建订单模块

**（1）service 模块下创建 service-order 模块。**

![创建订单模块](https://img-blog.csdnimg.cn/aacc22eca33b4da1ac3f55855526754d.png)

![创建订单模块](https://img-blog.csdnimg.cn/112ee2d4c65e410eaf803573cf5c12d5.png)

##### 1.3、生成订单相关代码

![生成订单相关代码](https://img-blog.csdnimg.cn/e9cf376a41574902845d6012b735ae58.png)

##### 1.4、创建启动类

```java
package com.myxh.smart.planet.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * @author MYXH
 * @date 2023/10/14
 */
@SpringBootApplication
public class ServiceOrderApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
}
```

##### 1.5、创建配置文件

```properties
# 服务端口
server.port=8302

# 服务名
spring.application.name=service-order

# 环境设置：dev、test、prod
spring.profiles.active=dev

# MySQL 数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/smart_planet_order?characterEncoding=utf-8&useSSL=false
spring.datasource.username=MYXH
spring.datasource.password=520.ILY!

# 返回 Json 的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

# MyBatis 日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 设置 mapper.xml 的路径
mybatis-plus.mapper-locations=classpath:com/myxh/smart/planet/order/mapper/xml/*.xml
```

##### 1.6、创建配置类

```java
package com.myxh.smart.planet.order.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author MYXH
 * @date 2023/10/14
 * @description 配置类
 */
@Configuration
@MapperScan("com.myxh.smart.planet.order.mapper")
public class OrderConfig
{
    /**
     * 分页插件
     *
     * @return MyBatis Plus 拦截器
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor()
    {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));

        return interceptor;
    }
}
```

#### 2、开发订单列表接口

##### 2.1、编写 OrderInfoController

```java
package com.myxh.smart.planet.order.controller;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.myxh.smart.planet.model.order.OrderInfo;
import com.myxh.smart.planet.order.service.OrderInfoService;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vo.order.OrderInfoQueryVo;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/14
 *
 * <p>
 * 订单信息 前端控制器
 * </p>
 */
@Tag(name = "订单信息管理", description = "订单信息管理接口")
@RestController
@RequestMapping("/admin/order/order/info")
public class OrderInfoController
{
    @Autowired
    private OrderInfoService orderInfoService;

    /**
     * 条件查询订单分页
     *
     * @param current          当前页码
     * @param limit            每页记录数
     * @param orderInfoQueryVo 查询对象
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "条件查询订单分页", description = "条件查询订单分页")
    @GetMapping("find/query/page/{current}/{limit}")
    public Result<Map<String, Object>> orderInfoList(
            @Parameter(name = "current", description = "当前页码", required = true)
            @PathVariable("current") Long current,
            @Parameter(name = "limit", description = "每页记录数", required = true)
            @PathVariable("limit") Long limit,
            @Parameter(name = "orderInfoVo", description = "查询对象")
            OrderInfoQueryVo orderInfoQueryVo)
    {
        // 创建 page 对象
        Page<OrderInfo> orderInfoPageParam = new Page<>(current, limit);
        Map<String, Object> orderInfoPage = orderInfoService.selectOrderInfoPage(orderInfoPageParam, orderInfoQueryVo);

        return Result.ok(orderInfoPage);
    }
}
```

##### 2.2、编写 Service

**（1）OrderInfoService 定义方法。**

```java
package com.myxh.smart.planet.order.service;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.IService;
import com.myxh.smart.planet.model.order.OrderInfo;
import com.myxh.smart.planet.vo.order.OrderInfoQueryVo;

import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/14
 *
 * <p>
 * 订单信息 服务类
 * </p>
 */
public interface OrderInfoService extends IService<OrderInfo>
{
    /**
     * 订单信息列表
     *
     * @param orderInfoPageParam 订单信息页面参数
     * @param orderInfoQueryVo 查询对象
     * @return orderInfoPage 订单信息页面
     */
    Map<String, Object> selectOrderInfoPage(Page<OrderInfo> orderInfoPageParam, OrderInfoQueryVo orderInfoQueryVo);
}
```

**（2）OrderInfoServiceImpl 实现方法。**

```java
package com.myxh.smart.planet.order.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.order.OrderDetail;
import com.myxh.smart.planet.model.order.OrderInfo;
import com.myxh.smart.planet.order.mapper.OrderInfoMapper;
import com.myxh.smart.planet.order.service.OrderDetailService;
import com.myxh.smart.planet.order.service.OrderInfoService;
import com.myxh.smart.planet.vo.order.OrderInfoQueryVo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/14
 *
 * <p>
 * 订单信息 服务实现类
 * </p>
 */
@Service
public class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> implements OrderInfoService
{
    @Autowired
    private OrderDetailService orderDetailService;

    /**
     * 订单信息列表
     *
     * @param orderInfoPageParam 订单信息页面参数
     * @param orderInfoQueryVo   查询对象
     * @return orderInfoPage 订单信息页面
     */
    @Override
    public Map<String, Object> selectOrderInfoPage(Page<OrderInfo> orderInfoPageParam, OrderInfoQueryVo orderInfoQueryVo)
    {
        // orderInfoQueryVo 获取查询条件
        Long userId = orderInfoQueryVo.getUserId();
        String outTradeNo = orderInfoQueryVo.getOutTradeNo();
        String phone = orderInfoQueryVo.getPhone();
        String createTimeBegin = orderInfoQueryVo.getCreateTimeBegin();
        String createTimeEnd = orderInfoQueryVo.getCreateTimeEnd();
        Integer orderStatus = orderInfoQueryVo.getOrderStatus();

        // 判断条件值是否为空，不为空，进行条件封装
        QueryWrapper<OrderInfo> wrapper = new QueryWrapper<>();

        if (!ObjectUtils.isEmpty(orderStatus))
        {
            wrapper.eq("order_status", orderStatus);
        }
        if (!ObjectUtils.isEmpty(userId))
        {
            wrapper.eq("user_id", userId);
        }
        if (StringUtils.hasLength(outTradeNo))
        {
            wrapper.eq("out_trade_no", outTradeNo);
        }
        if (StringUtils.hasLength(phone))
        {
            wrapper.eq("phone", phone);
        }
        if (StringUtils.hasLength(createTimeBegin))
        {
            wrapper.ge("create_time", createTimeBegin);
        }
        if (StringUtils.hasLength(createTimeEnd))
        {
            wrapper.le("create_time", createTimeEnd);
        }

        // 调用实现条件分页查询
        Page<OrderInfo> pages = baseMapper.selectPage(orderInfoPageParam, wrapper);
        Long totalCount = pages.getTotal();
        Long pageCount = pages.getPages();
        List<OrderInfo> records = pages.getRecords();

        // 订单里面包含详情内容，封装详情数据，根据订单 id 查询详情
        records.stream().forEach(this::getOrderDetail);

        // 所有需要数据封装 map 集合，最终返回
        Map<String, Object> orderInfoPage = new HashMap<>();
        orderInfoPage.put("total", totalCount);
        orderInfoPage.put("pageCount", pageCount);
        orderInfoPage.put("records", records);

        return orderInfoPage;
    }

    /**
     * 查询订单详情数据
     *
     * @param orderInfo 订单信息
     * @return orderInfo 订单信息
     */
    private OrderInfo getOrderDetail(OrderInfo orderInfo)
    {
        // 订单 id
        Long id = orderInfo.getId();

        // 查询订单详情
        OrderDetail orderDetail = orderDetailService.getById(id);

        if (orderDetail != null)
        {
            String courseName = orderDetail.getCourseName();
            orderInfo.getParam().put("courseName", courseName);
        }

        return orderInfo;
    }
}
```

#### 3、配置网关

##### 3.1、Nacos 注册

**（1）service-order 启动类添加注解。**

```java
package com.myxh.smart.planet.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

/**
 * @author MYXH
 * @date 2023/10/14
 */
@SpringBootApplication
@EnableDiscoveryClient
public class ServiceOrderApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceOrderApplication.class, args);
    }
}
```

**（2）service-order 配置文件。**

```properties
# 服务端口
server.port=8302

# 服务名
spring.application.name=service-order

# 环境设置：dev、test、prod
spring.profiles.active=dev

# MySQL 数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/smart_planet_order?characterEncoding=utf-8&useSSL=false
spring.datasource.username=MYXH
spring.datasource.password=520.ILY!

# 返回 Json 的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

# MyBatis 日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 设置 mapper.xml 的路径
mybatis-plus.mapper-locations=classpath:com/myxh/smart/planet/order/mapper/xml/*.xml

# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

##### 3.2、配置路由规则

**（1）service-gateway 配置文件。**

```properties
# service-order 模块配置
# 设置路由 id
spring.cloud.gateway.routes[1].id=service-order
# 设置路由的 uri，lb 全称为 Load Balance 负载平衡
spring.cloud.gateway.routes[1].uri=lb://service-order
# 设置路由断言,代理 servicerId 为 auth-service 的 /auth/ 路径，/admin/order/order/info
spring.cloud.gateway.routes[1].predicates= Path=/*/order/**
```

#### 4、开发订单列表前端

##### 4.1、定义接口

**（1）创建 api/order/orderInfo.js。**

![定义接口](https://img-blog.csdnimg.cn/63e47698cc234ccbaf9763b736a3c6e6.png)

```javascript
import request from "@/utils/request";

const ORDER_INFO_API = "/admin/order/order/info";

export default {
  /**
   * 订单信息列表
   *
   * @param {number} current 当前页码
   * @param {number} limit 每页记录数
   * @param {Object} orderInfoQueryVo 查询对象
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  getPageList(current, limit, orderInfoQueryVo) {
    return request({
      url: `${ORDER_INFO_API}/find/query/page/${current}/${limit}`,
      method: "get",
      params: orderInfoQueryVo,
    });
  },
};
```

##### 4.2、创建路由

**（1）router/index.js 定义路由。**

```javascript
// 订单管理
{
  path: "/order",
  component: Layout,
  redirect: "/order/order/info/list",
  name: "Order",
  meta: { title: "订单管理", icon: "el-icon-truck" },
  alwaysShow: true,
  children: [
    {
      path: "order/info/list",
      name: "OrderInfo",
      component: () => import("@/views/order/list"),
      meta: { title: "订单列表" },
    },
  ],
},
```

##### 4.3、创建 vue 页面

**（1）创建 views/order/list.vue。**

![创建 vue 页面](https://img-blog.csdnimg.cn/c05dc3f618b34a39985828a42eae6ec9.png)

```html
<template>
  <div class="app-container">
    <el-card class="operate-container" shadow="never">
      <el-form :inline="true" class="demo-form-inline">
        <el-form-item>
          <el-input v-model="searchObj.outTradeNo" placeholder="订单号" />
        </el-form-item>
        <el-form-item>
          <el-input v-model="searchObj.phone" placeholder="手机" />
        </el-form-item>
        <el-form-item>
          <el-date-picker
            v-model="searchObj.createTimeBegin"
            type="date"
            placeholder="选择下单开始日期"
            value-format="yyyy-MM-dd"
          />
        </el-form-item>
        <el-form-item>
          <el-date-picker
            v-model="searchObj.createTimeEnd"
            type="date"
            placeholder="选择截止日期"
            value-format="yyyy-MM-dd"
          />
        </el-form-item>
        <el-form-item>
          <el-select
            v-model="searchObj.orderStatus"
            placeholder="订单状态"
            class="v-select patient-select"
          >
            <el-option
              v-for="item in statusList"
              :key="item.status"
              :label="item.name"
              :value="item.status"
            >
            </el-option>
          </el-select>
        </el-form-item>
        <el-button type="primary" icon="el-icon-search" @click="fetchData()"
          >查询</el-button
        >
        <el-button type="default" @click="resetData()">清空</el-button>
      </el-form>
    </el-card>

    <!-- 列表 -->
    <el-table
      v-loading="listLoading"
      :data="list"
      border
      fit
      highlight-current-row
    >
      <el-table-column label="序号" width="60" align="center">
        <template slot-scope="scope">
          {{ (page - 1) * limit + scope.$index + 1 }}
        </template>
      </el-table-column>
      <el-table-column prop="outTradeNo" label="订单号" width="160" />
      <el-table-column prop="courseName" label="课程名称" width="160">
        <template slot-scope="scope">
          {{ scope.row.param.courseName }}
        </template>
      </el-table-column>
      <el-table-column prop="finalAmount" label="订单金额" width="90" />
      <el-table-column prop="nickName" label="下单用户" />
      <el-table-column prop="phone" label="用户手机" />
      <el-table-column prop="payTime" label="支付时间" width="156" />
      <el-table-column prop="orderStatus" label="订单状态">
        <template slot-scope="scope">
          {{ scope.row.orderStatus == 0 ? "未支付" : "已支付" }}
        </template>
      </el-table-column>
      <el-table-column prop="createTime" label="下单时间" width="156" />
    </el-table>

    <!-- 分页组件 -->
    <el-pagination
      :current-page="page"
      :total="total"
      :page-size="limit"
      :page-sizes="[5, 10, 20, 30, 40, 50, 100]"
      style="padding: 30px 0; text-align: center"
      layout="sizes, prev, pager, next, jumper, ->, total, slot"
      @current-change="fetchData"
      @size-change="changeSize"
    />
  </div>
</template>

<script>
  import orderInfoAPI from "@/api/order/orderInfo";

  export default {
    data() {
      return {
        // 数据是否正在加载
        listLoading: true,

        // banner 列表
        list: null,

        // 数据库中的总记录数
        total: 0,

        // 默认页码
        page: 1,

        // 每页记录数
        limit: 10,

        // 查询表单对象
        searchObj: {},

        statusList: [
          {
            status: 0,
            name: "未支付",
          },
          {
            status: 1,
            name: "已支付",
          },
        ],
      };
    },

    // 生命周期函数：内存准备完毕，页面尚未渲染
    created() {
      this.fetchData();
    },

    // 生命周期函数：内存准备完毕，页面渲染成功
    mounted() {
      console.log("list mounted...");
    },

    methods: {
      // 当页码发生改变的时候
      changeSize(size) {
        this.limit = size;
        this.fetchData(1);
      },

      // 加载 banner 列表数据
      fetchData(page = 1) {
        // 验证开始时间和结束时间的合法性
        if (!this.validateDateRange()) {
          return;
        }

        // 异步获取远程数据（ajax）
        this.page = page;
        orderInfoAPI
          .getPageList(this.page, this.limit, this.searchObj)
          .then((response) => {
            this.list = response.data.records;
            this.total = response.data.total;
            // 数据加载并绑定成功
            this.listLoading = false;
          });
      },

      // 验证开始时间和结束时间的合法性
      validateDateRange() {
        if (
          this.searchObj.createTimeBegin &&
          this.searchObj.createTimeEnd &&
          this.searchObj.createTimeBegin > this.searchObj.createTimeEnd
        ) {
          this.$message.error("开始时间不能晚于结束时间");
          return false;
        }
        return true;
      },

      // 重置查询表单
      resetData() {
        console.log("重置查询表单");
        this.searchObj = {};
        this.fetchData();
      },
    },
  };
</script>
```

### 五、后台管理系统-营销管理模块

#### 1、环境准备

##### 1.1、创建数据库表

![创建数据库表](https://img-blog.csdnimg.cn/68ba4cb8192346d58a83e12585975c8b.png)

##### 1.2、创建营销模块

**（1）service 模块下创建 service-activity 模块。**

![创建营销模块](https://img-blog.csdnimg.cn/055e41e00a72423ba2480fb252299fad.png)

![创建营销模块](https://img-blog.csdnimg.cn/5297012409b6444eb04a000143dc061c.png)

##### 1.3、生成营销相关代码

![生成营销相关代码](https://img-blog.csdnimg.cn/e8472652e2804a8789b0f77b27a84f6e.png)

##### 1.4、创建启动类

```java
package com.myxh.smart.planet.activity;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

/**
 * @author MYXH
 * @date 2023/10/15
 */
@SpringBootApplication
@EnableDiscoveryClient
public class ServiceActivityApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceActivityApplication.class, args);
    }
}
```

##### 1.5、创建配置文件

```properties
# 服务端口
server.port=8303

# 服务名
spring.application.name=service-activity

# 环境设置：dev、test、prod
spring.profiles.active=dev

# MySQL 数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/smart_planet_activity?characterEncoding=utf-8&useSSL=false
spring.datasource.username=MYXH
spring.datasource.password=520.ILY!

# 返回 Json 的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

# MyBatis 日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 设置 mapper.xml 的路径
mybatis-plus.mapper-locations=classpath:com/myxh/smart/planet/activity/mapper/xml/*.xml

# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

##### 1.6、创建配置类

```java
package com.myxh.smart.planet.activity.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author MYXH
 * @date 2023/10/15
 * @description 配置类
 */
@Configuration
@MapperScan("com.myxh.smart.planet.activity.mapper")
public class ActivityConfig
{
    /**
     * 分页插件
     *
     * @return MyBatis Plus 拦截器
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor()
    {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));

        return interceptor;
    }
}
```

#### 2、开发优惠券相关接口

##### 2.1、编写 CouponInfoController

```java
package com.myxh.smart.planet.activity.controller;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.myxh.smart.planet.activity.service.CouponInfoService;
import com.myxh.smart.planet.model.activity.CouponInfo;
import com.myxh.smart.planet.model.activity.CouponUse;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vo.activity.CouponUseQueryVo;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/15
 *
 * <p>
 * 优惠券信息 前端控制器
 * </p>
 */
@Tag(name = "优惠券信息管理", description = "优惠券信息管理接口")
@RestController
@RequestMapping("/admin/activity/coupon/info")
public class CouponInfoController
{
    @Autowired
    private CouponInfoService couponInfoService;

    /**
     * 条件查询优惠券分页
     *
     * @param current 当前页码
     * @param limit   每页记录数
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "条件查询优惠券分页", description = "条件查询优惠券分页")
    @GetMapping("find/query/page/{current}/{limit}")
    public Result<IPage<CouponInfo>> couponInfoList(
            @Parameter(name = "current", description = "当前页码", required = true) @PathVariable("current") Long current,
            @Parameter(name = "limit", description = "每页记录数", required = true) @PathVariable("limit") Long limit)
    {
        Page<CouponInfo> couponInfoPageParam = new Page<>(current, limit);
        IPage<CouponInfo> couponInfoPageModel = couponInfoService.page(couponInfoPageParam);

        return Result.ok(couponInfoPageModel);
    }

    /**
     * 根据 id 查询优惠券
     *
     * @param id id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "查询", description = "根据 id 查询优惠券")
    @GetMapping("get/{id}")
    public Result<CouponInfo> get(@PathVariable("id") String id)
    {
        CouponInfo couponInfo = couponInfoService.getById(id);

        return Result.ok(couponInfo);
    }

    /**
     * 添加优惠券
     *
     * @param couponInfo 优惠券数据
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "添加", description = "添加优惠券")
    @PostMapping("save")
    public Result<Void> save(@RequestBody CouponInfo couponInfo)
    {
        couponInfoService.save(couponInfo);

        return Result.ok(null);
    }

    /**
     * 修改优惠券
     *
     * @param couponInfo 优惠券数据
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "修改", description = "修改优惠券")
    @PutMapping("update")
    public Result<Void> updateById(@RequestBody CouponInfo couponInfo)
    {
        couponInfoService.updateById(couponInfo);

        return Result.ok(null);
    }

    /**
     * 逻辑删除优惠券
     *
     * @param id id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除", description = "逻辑删除优惠券")
    @DeleteMapping("remove/{id}")
    public Result<Void> remove(@PathVariable("id") String id)
    {
        couponInfoService.removeById(id);

        return Result.ok(null);
    }

    /**
     * 批量删除优惠券
     *
     * @param idList id 数组，Json 数组 [1,2,3,...]
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "批量删除", description = "批量删除优惠券")
    @DeleteMapping("remove/batch")
    public Result<Void> batchRemove(@RequestBody List<String> idList)
    {
        couponInfoService.removeByIds(idList);

        return Result.ok(null);
    }

    /**
     * 条件查询已经使用的优惠券分页
     *
     * @param current 当前页码
     * @param limit   每页记录数
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "条件查已经使用的优惠券分页", description = "条件查已经使用的优惠券分页")
    @GetMapping("coupon/use/{current}/{limit}")
    public Result<IPage<CouponUse>> couponUseList(
            @Parameter(name = "current", description = "当前页码", required = true)
            @PathVariable("current") Long current,
            @Parameter(name = "limit", description = "每页记录数", required = true)
            @PathVariable("limit") Long limit,
            @Parameter(name = "couponUseVo", description = "查询对象")
            @RequestBody(required = false) CouponUseQueryVo couponUseQueryVo)
    {
        Page<CouponUse> couponUsePageParam = new Page<>(current, limit);
        IPage<CouponUse> couponUsePageModel = couponInfoService.selectCouponUsePage(couponUsePageParam, couponUseQueryVo);

        return Result.ok(couponUsePageModel);
    }
}
```

##### 2.2、编写 Service

**（1）CouponInfoService 定义方法。**

```java
package com.myxh.smart.planet.activity.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.IService;
import com.myxh.smart.planet.model.activity.CouponInfo;
import com.myxh.smart.planet.model.activity.CouponUse;
import com.myxh.smart.planet.vo.activity.CouponUseQueryVo;

/**
 * @author MYXH
 * @date 2023/10/15
 *
 * <p>
 * 优惠券信息 服务类
 * </p>
 */
public interface CouponInfoService extends IService<CouponInfo>
{
    /**
     * 优惠券信息列表
     *
     * @param couponUsePageParam 优惠券使用页面参数
     * @param couponUseQueryVo 查询对象
     * @return couponUsePageModel 优惠券使用页面
     */
    IPage<CouponUse> selectCouponUsePage(Page<CouponUse> couponUsePageParam, CouponUseQueryVo couponUseQueryVo);
}
```

## Day 11-营销管理模块和公众号菜单管理

### 一、优惠券列表接口

#### 1、编写获取用户信息接口

##### 1.1、创建 service-user 模块

**（1）获取优惠券详情时候，需要获取使用者的昵称和手机号，所以使用远程调用实现此功能。**

![创建 service-user 模块](https://img-blog.csdnimg.cn/2e5c845599c143de835655f33107e4e9.png)

![创建 service-user 模块](https://img-blog.csdnimg.cn/89d5c43d62e947ff8a9b7a40cc5b6a4d.png)

##### 1.2、生成相关代码

![生成相关代码](https://img-blog.csdnimg.cn/77ffa85a6d7843aab3795e9a8fa30265.png)

##### 1.3、创建启动类

```java
package com.myxh.smart.planet.user;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

/**
 * @author MYXH
 * @date 2023/10/15
 */
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan("com.myxh.smart.planet.user.mapper")
public class ServiceUserApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceUserApplication.class, args);
    }
}
```

##### 1.4、创建配置文件

```properties
# 服务端口
server.port=8304

# 服务名
spring.application.name=service-user

# 环境设置：dev、test、prod
spring.profiles.active=dev

# MySQL 数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/smart_planet_user?characterEncoding=utf-8&useSSL=false
spring.datasource.username=MYXH
spring.datasource.password=520.ILY!

# 返回 Json 的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

# MyBatis 日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 设置 mapper.xml 的路径
mybatis-plus.mapper-locations=classpath:com/myxh/smart/planet/user/mapper/xml/*.xml

# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

##### 1.5、编写 UserInfocontroller

**实现根据用户 id 获取用户信息接口。**

```java
package com.myxh.smart.planet.user.controller;

import com.myxh.smart.planet.model.user.UserInfo;
import com.myxh.smart.planet.user.service.UserInfoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author MYXH
 * @date 2023/10/15
 *
 * <p>
 * 用户信息 前端控制器
 * </p>
 */
@Tag(name = "用户信息管理", description = "用户信息管理接口")
@RestController
@RequestMapping("/admin/user/user/info")
public class UserInfoController
{
    @Autowired
    private UserInfoService userService;

    /**
     * 根据 id 查询用户信息
     *
     * @param id id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "查询", description = "根据 id 查询用户信息")
    @GetMapping("inner/get/{id}")
    public UserInfo getUserInfoById(@PathVariable("id") Long id)
    {
        UserInfo userInfo = userService.getById(id);

        return userInfo;
    }
}
```

##### 1.6、配置网关

**在网关配置文件配置路径。**

```properties
# service-user 模块配置
# 设置路由 id
spring.cloud.gateway.routes[3].id=service-user
# 设置路由的 uri，lb 全称为 Load Balance 负载平衡
spring.cloud.gateway.routes[3].uri=lb://service-user
# 设置路由断言,代理 servicerId 为 auth-service 的 /auth/ 路径，/admin/user/user/info
spring.cloud.gateway.routes[3].predicates= Path=/*/user/**
```

#### 2、创建模块定义远程接口

##### 2.1、创建模块

**在 SmartPlanet/service-client/service-user-client。**

![创建模块](https://img-blog.csdnimg.cn/752e292664c748ccb4ee9fb138256f3e.png)

##### 2.2、service-client 引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.myxh.smart.planet</groupId>
        <artifactId>SmartPlanet</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>service-client</artifactId>
    <packaging>pom</packaging>
    <modules>
        <module>service-user-client</module>
    </modules>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- model 数据载体 -->
        <dependency>
            <groupId>com.myxh.smart.planet</groupId>
            <artifactId>model</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>

        <!-- service-utils -->
        <dependency>
            <groupId>com.myxh.smart.planet</groupId>
            <artifactId>service-utils</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>

        <!-- Web 需要启动项目 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>provided</scope>
        </dependency>

        <!-- openfeign 服务调用 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
```

##### 2.3、定义远程调用的接口

```java
package com.myxh.smart.planet.client.user;

import com.myxh.smart.planet.model.user.UserInfo;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

/**
 * @author MYXH
 * @date 2023/10/15
 */
@FeignClient("service-user")
public interface UserInfoFeignClient
{
    @Operation(summary = "查询", description = "根据 id 查询用户信息")
    @GetMapping("/admin/user/user/info/inner/get/{id}")
    UserInfo getUserInfoById(@PathVariable("id") Long id);
}
```

#### 3、编写 Service 实现方法

##### 3.1、service 引入依赖

```xml
<!-- 负载平衡 loadbalancer -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

##### 3.2、service-activity 引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.myxh.smart.planet</groupId>
        <artifactId>service</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>service-activity</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- service-user-client -->
        <dependency>
            <groupId>com.myxh.smart.planet</groupId>
            <artifactId>service-user-client</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>

        <!-- mybatis-plus-generator -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.5.3.1</version>
        </dependency>

        <!-- freemarker -->
        <dependency>
            <groupId>org.freemarker</groupId>
            <artifactId>freemarker</artifactId>
            <version>2.3.32</version>
        </dependency>
    </dependencies>
</project>
```

##### 3.2、service-activity 添加注解

```java
package com.myxh.smart.planet.activity;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;



/**
 * @author MYXH
 * @date 2023/10/15
 */
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients(basePackages = "com.myxh.smart.planet")
@MapperScan("com.myxh.smart.planet.activity.mapper")
public class ServiceActivityApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceActivityApplication.class, args);
    }
}
```

##### 3.3、CouponInfoServiceImpl 实现方法

**远程调用，根据用户 id 获取用户信息。**

```java
package com.myxh.smart.planet.activity.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.activity.mapper.CouponInfoMapper;
import com.myxh.smart.planet.activity.service.CouponInfoService;
import com.myxh.smart.planet.activity.service.CouponUseService;
import com.myxh.smart.planet.client.user.UserInfoFeignClient;
import com.myxh.smart.planet.model.activity.CouponInfo;
import com.myxh.smart.planet.model.activity.CouponUse;
import com.myxh.smart.planet.model.user.UserInfo;
import com.myxh.smart.planet.vo.activity.CouponUseQueryVo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/15
 *
 * <p>
 * 优惠券信息 服务实现类
 * </p>
 */
@Service
public class CouponInfoServiceImpl extends ServiceImpl<CouponInfoMapper, CouponInfo> implements CouponInfoService
{
    @Autowired
    private CouponUseService couponUseService;

    @Autowired
    private UserInfoFeignClient userInfoFeignClient;

    /**
     * 优惠券信息列表
     *
     * @param couponUsePageParam 优惠券使用页面参数
     * @param couponUseQueryVo   查询对象
     * @return couponUsePageModel 优惠券使用页面
     */
    @Override
    public IPage<CouponUse> selectCouponUsePage(Page<CouponUse> couponUsePageParam, CouponUseQueryVo couponUseQueryVo)
    {
        // 获取条件
        Long couponId = couponUseQueryVo.getCouponId();
        String couponStatus = couponUseQueryVo.getCouponStatus();
        String getTimeBegin = couponUseQueryVo.getGetTimeBegin();
        String getTimeEnd = couponUseQueryVo.getGetTimeEnd();

        // 封装条件
        QueryWrapper<CouponUse> wrapper = new QueryWrapper<>();

        if (!ObjectUtils.isEmpty(couponId))
        {
            wrapper.eq("coupon_id", couponId);
        }
        if (StringUtils.hasLength(couponStatus))
        {
            wrapper.eq("coupon_status", couponStatus);
        }
        if (StringUtils.hasLength(getTimeBegin))
        {
            wrapper.ge("get_time", getTimeBegin);
        }
        if (StringUtils.hasLength(getTimeEnd))
        {
            wrapper.le("get_time", getTimeEnd);
        }

        // 调用方法查询
        IPage<CouponUse> CouponUsePage = couponUseService.page(couponUsePageParam, wrapper);

        // 封装用户昵称和手机号
        List<CouponUse> couponUseList = CouponUsePage.getRecords();

        // 遍历
        couponUseList.stream().forEach(this::getUserInfoByCouponUse);

        return CouponUsePage;
    }

    /**
     * 封装用户昵称和手机号
     *
     * @param couponUse 优惠券使用数据
     * @return couponUse 优惠券使用数据
     */
    private CouponUse getUserInfoByCouponUse(CouponUse couponUse)
    {
        // 获取用户 id
        Long userId = couponUse.getUserId();

        if (!ObjectUtils.isEmpty(userId))
        {
            // 远程调用
            UserInfo userInfo = userInfoFeignClient.getUserInfoById(userId);

            if (userInfo != null)
            {
                couponUse.getParam().put("nickName", userInfo.getNickName());
                couponUse.getParam().put("phone", userInfo.getPhone());
            }
        }

        return couponUse;
    }
}
```

#### 4、配置网关

##### 4.1、配置路由规则

**（1）service-gateway 配置文件。**

```properties
# service-activity 模块配置
# 设置路由 id
spring.cloud.gateway.routes[2].id=service-activity
# 设置路由的 uri，lb 全称为 Load Balance 负载平衡
spring.cloud.gateway.routes[2].uri=lb://service-activity
# 设置路由断言,代理 servicerId 为 auth-service 的 /auth/ 路径，/admin/activity/coupon/info
spring.cloud.gateway.routes[2].predicates= Path=/*/activity/**
```

#### 5、整合优惠券前端

##### 5.1、定义接口

**（1）创建 api/activity/couponInfo.js。**

![定义接口](https://img-blog.csdnimg.cn/e9ff20a0f43f4b09b3b5b23a32ee5231.png)

```javascript
import request from "@/utils/request";

const COUPON_INFO_API = "/admin/activity/coupon/info";

export default {
  /**
   * 优惠券信息列表
   *
   * @param {number} current 当前页码
   * @param {number} limit 每页记录数
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  getPageList(current, limit) {
    return request({
      url: `${COUPON_INFO_API}/find/query/page/${current}/${limit}`,
      method: "get",
    });
  },

  /**
   * 根据 id 获取优惠券信息
   *
   * @param {number} id id
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  getById(id) {
    return request({
      url: `${COUPON_INFO_API}/get/${id}`,
      method: "get",
    });
  },

  /**
   * 添加优惠券信息
   *
   * @param {Object} couponInfo 优惠券信息
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  save(couponInfo) {
    return request({
      url: `${COUPON_INFO_API}/save`,
      method: "post",
      data: couponInfo,
    });
  },

  /**
   * 根据 id 修改优惠券信息
   *
   * @param {Object} couponInfo 优惠券信息
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  updateById(couponInfo) {
    return request({
      url: `${COUPON_INFO_API}/update`,
      method: "put",
      data: couponInfo,
    });
  },

  /**
   * 删除优惠券信息
   *
   * @param {number} id id
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  removeById(id) {
    return request({
      url: `${COUPON_INFO_API}/remove/${id}`,
      method: "delete",
    });
  },

  /**
   * 批量删除优惠券信息
   *
   * @param {Array}idList id 数组，Json 数组 [1,2,3,...]
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  removeRows(idList) {
    return request({
      url: `${COUPON_INFO_API}/remove/batch`,
      method: "delete",
      data: idList,
    });
  },

  /**
   * 已经使用的优惠券信息列表
   *
   * @param {number} current 当前页码
   * @param {number} limit 每页记录数
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  getPageCouponUseList(current, limit, searchObj) {
    return request({
      url: `${COUPON_INFO_API}/coupon/use/${current}/${limit}`,
      method: "get",
      params: searchObj,
    });
  },
};
```

##### 5.2、创建路由

**（1）router/index.js 定义路由。**

```javascript
  // 营销活动管理
  {
    path: "/activity",
    component: Layout,
    redirect: "/coupon/info/list",
    name: "Activity",
    meta: { title: "营销活动管理", icon: "el-icon-football" },
    alwaysShow: true,
    children: [
      {
        path: "coupon/info/list",
        name: "CouponInfo",
        component: () => import("@/views/activity/couponInfo/list"),
        meta: { title: "优惠券列表" },
      },
      {
        path: "coupon/info/add",
        name: "CouponInfoAdd",
        component: () => import("@/views/activity/couponInfo/form"),
        meta: { title: "添加优惠券" },
      },
      {
        path: "coupon/info/edit/:id",
        name: "CouponInfoEdit",
        component: () => import("@/views/activity/couponInfo/form"),
        meta: { title: "编辑优惠券", noCache: true },
        hidden: true,
      },
      {
        path: "coupon/info/show/:id",
        name: "CouponInfoShow",
        component: () => import("@/views/activity/couponInfo/show"),
        meta: { title: "优惠券详情", noCache: true },
        hidden: true,
      },
    ],
  },
```

##### 5.3、创建 vue 页面

**（1）创建 views/activity/couponInfo/页面。**

![创建 vue 页面](https://img-blog.csdnimg.cn/9c6d990fbe7d44c397fcdd4efb371e3d.png)

**（2）list.vue**

```html
<template>
  <div class="app-container">
    <!-- 工具条 -->
    <el-card class="operate-container" shadow="never">
      <i class="el-icon-tickets" style="margin-top: 5px"></i>
      <span style="margin-top: 5px">数据列表</span>
      <el-button class="btn-add" size="mini" @click="add()">添加</el-button>
    </el-card>

    <!-- banner 列表 -->
    <el-table
      v-loading="listLoading"
      :data="list"
      element-loading-text="数据正在加载......"
      border
      fit
      highlight-current-row
    >
      <el-table-column label="序号" width="70" align="center">
        <template slot-scope="scope">
          {{ (page - 1) * limit + scope.$index + 1 }}
        </template>
      </el-table-column>

      <el-table-column prop="couponName" label="购物券名称" />
      <el-table-column prop="couponType" label="购物券类型">
        <template slot-scope="scope">
          {{ scope.row.couponType === "1" ? "注册卷" : "推荐赠送卷" }}
        </template>
      </el-table-column>
      <el-table-column label="规则">
        <template slot-scope="scope">
          {{ "现金卷：" + scope.row.amount + "元" }}
        </template>
      </el-table-column>
      <el-table-column label="使用范围 "> 所有商品 </el-table-column>
      <el-table-column prop="publishCount" label="发行数量" />
      <el-table-column prop="expireTime" label="过期时间" />
      <el-table-column prop="createTime" label="创建时间" />
      <el-table-column label="操作" width="150" align="center">
        <template slot-scope="scope">
          <router-link :to="'/activity/coupon/info/edit/' + scope.row.id">
            <el-button size="mini" type="text">修改</el-button>
          </router-link>
          <el-button
            size="mini"
            type="text"
            @click="removeDataById(scope.row.id)"
            >删除</el-button
          >
          <router-link :to="'/activity/coupon/info/show/' + scope.row.id">
            <el-button size="mini" type="text">详情</el-button>
          </router-link>
        </template>
      </el-table-column>
    </el-table>

    <!-- 分页组件 -->
    <el-pagination
      :current-page="page"
      :total="total"
      :page-size="limit"
      :page-sizes="[5, 10, 20, 30, 40, 50, 100]"
      style="padding: 30px 0; text-align: center"
      layout="sizes, prev, pager, next, jumper, ->, total, slot"
      @current-change="fetchData"
      @size-change="changeSize"
    />
  </div>
</template>

<script>
  import couponInfoAPI from "@/api/activity/couponInfo";

  export default {
    data() {
      return {
        // 数据是否正在加载
        listLoading: true,
        // banner列表
        list: null,
        // 数据库中的总记录数
        total: 0,
        // 默认页码
        page: 1,
        // 每页记录数
        limit: 10,
        // 查询表单对象
        searchObj: {},
        // 批量选择中选择的记录列表
        multipleSelection: [],
      };
    },

    // 生命周期函数：内存准备完毕，页面尚未渲染
    created() {
      console.log("list created...");
      this.fetchData();
    },

    // 生命周期函数：内存准备完毕，页面渲染成功
    mounted() {
      console.log("list mounted...");
    },

    methods: {
      // 当页码发生改变的时候
      changeSize(size) {
        console.log(size);
        this.limit = size;
        this.fetchData(1);
      },

      add() {
        this.$router.push({ path: "/activity/coupon/info/add" });
      },

      // 加载 banner 列表数据
      fetchData(page = 1) {
        console.log("翻页" + page);
        // 异步获取远程数据（ajax）
        this.page = page;

        couponInfoAPI
          .getPageList(this.page, this.limit, this.searchObj)
          .then((response) => {
            this.list = response.data.records;
            this.total = response.data.total;

            // 数据加载并绑定成功
            this.listLoading = false;
          });
      },

      // 重置查询表单
      resetData() {
        console.log("重置查询表单");
        this.searchObj = {};
        this.fetchData();
      },

      // 根据 id 删除数据
      removeDataById(id) {
        // debugger
        this.$confirm("此操作将永久删除该记录, 是否继续?", "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning",
        })
          .then(() => {
            // promise
            // 点击确定，远程调用ajax
            return couponInfoAPI.removeById(id);
          })
          .then((response) => {
            this.fetchData(this.page);
            if (response.code) {
              this.$message({
                type: "success",
                message: "删除成功!",
              });
            }
          })
          .catch(() => {
            this.$message({
              type: "info",
              message: "已取消删除",
            });
          });
      },
    },
  };
</script>
```

**（3）form.vue**

```html
<template>
  <div class="app-container">
    <el-form label-width="120px">
      <el-form-item label="优惠券名称">
        <el-input v-model="couponInfo.couponName" />
      </el-form-item>
      <el-form-item label="优惠券类型">
        <el-radio-group v-model="couponInfo.couponType">
          <el-radio label="1">注册卷</el-radio>
          <el-radio label="2">推荐购买卷</el-radio>
        </el-radio-group>
      </el-form-item>
      <el-form-item label="金额">
        <el-input-number v-model="couponInfo.amount" :min="0" />
      </el-form-item>
      <el-form-item label="发行数量">
        <el-input-number v-model="couponInfo.publishCount" :min="0" />
      </el-form-item>
      <el-form-item label="领取时间">
        <el-date-picker
          v-model="couponInfo.startTime"
          type="date"
          placeholder="选择开始日期"
          value-format="yyyy-MM-dd"
        />
        至
        <el-date-picker
          v-model="couponInfo.endTime"
          type="date"
          placeholder="选择结束日期"
          value-format="yyyy-MM-dd"
        />
      </el-form-item>
      <el-form-item label="过期时间">
        <el-date-picker
          v-model="couponInfo.expireTime"
          type="datetime"
          placeholder="选择过期时间"
          value-format="yyyy-MM-dd HH:mm:ss"
        />
      </el-form-item>
      <el-form-item label="直播详情">
        <el-input v-model="couponInfo.ruleDesc" type="textarea" rows="5" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="saveOrUpdate">保存</el-button>
        <el-button @click="back">返回</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
  import couponInfoAPI from "@/api/activity/couponInfo";

  const defaultForm = {
    id: "",
    couponType: "1",
    couponName: "",
    amount: "0",
    conditionAmount: "0",
    startTime: "",
    endTime: "",
    rangeType: "1",
    ruleDesc: "",
    publishCount: "",
    perLimit: "1",
    useCount: "0",
    receiveCount: "",
    expireTime: "",
    publishStatus: "",
  };

  export default {
    data() {
      return {
        couponInfo: defaultForm,
        saveBtnDisabled: false,

        keyword: "",
        skuInfoList: [],
      };
    },

    // 监听器
    watch: {
      $route(to, from) {
        console.log("路由变化...");
        console.log(to);
        console.log(from);
        this.init();
      },
    },

    // 生命周期方法（在路由切换，组件不变的情况下不会被调用）
    created() {
      console.log("form created...");
      this.init();
    },

    methods: {
      // 表单初始化
      init() {
        // debugger
        if (this.$route.params && this.$route.params.id) {
          const id = this.$route.params.id;
          this.fetchDataById(id);
        } else {
          // 对象拓展运算符：拷贝对象，而不是赋值对象的引用
          this.couponInfo = { ...defaultForm };
        }
      },

      saveOrUpdate() {
        // 防止表单重复提交
        this.saveBtnDisabled = true;

        if (!this.couponInfo.couponName) {
          this.$message.error("请输入优惠券名称");
          this.saveBtnDisabled = false;

          return;
        }

        if (!this.couponInfo.publishCount) {
          this.$message.error("请输入发行数量");
          this.saveBtnDisabled = false;

          return;
        }

        // 验证开始时间和结束时间的合法性
        if (!this.validateDateRange()) {
          return;
        }

        if (!this.couponInfo.id) {
          this.saveData();
        } else {
          this.updateData();
        }
      },

      // 验证开始时间和结束时间的合法性
      validateDateRange() {
        if (
          (this.couponInfo.startTime &&
            this.couponInfo.endTime &&
            this.couponInfo.startTime > this.couponInfo.endTime) ||
          this.couponInfo.endTime > this.couponInfo.expireTime
        ) {
          this.$message.error("开始时间不能晚于结束时间");
          return false;
        }
        return true;
      },

      // 新增
      saveData() {
        couponInfoAPI.save(this.couponInfo).then((response) => {
          if (response.code) {
            this.$message({
              type: "success",
              message: response.message,
            });
            this.$router.push({ path: "/activity/coupon/info/list" });
          }
        });
      },

      // 根据 id 更新记录
      updateData() {
        couponInfoAPI.updateById(this.couponInfo).then((response) => {
          debugger;
          if (response.code) {
            this.$message({
              type: "success",
              message: response.message,
            });
            this.$router.push({ path: "/activity/coupon/info/list" });
          }
        });
      },

      back() {
        this.$router.push({ path: "/activity/coupon/info/list" });
      },

      // 根据 id 查询记录
      fetchDataById(id) {
        couponInfoAPI.getById(id).then((response) => {
          this.couponInfo = response.data;
        });
      },
    },
  };
</script>
```

**（4）show.vue**

```html
<template>
  <div class="app-container">
    <h4>优惠券信息</h4>
    <table
      class="table table-striped table-condenseda table-bordered"
      width="100%"
    >
      <tbody>
        <tr>
          <th width="15%">优惠券名称</th>
          <td width="35%">
            <b style="font-size: 14px">{{ couponInfo.couponName }}</b>
          </td>
          <th width="15%">优惠券类型</th>
          <td width="35%">
            {{ couponInfo.couponType === "1" ? "注册卷" : "推荐赠送卷" }}
          </td>
        </tr>
        <tr>
          <th>发行数量</th>
          <td>{{ couponInfo.publishCount }}</td>
          <th>每人限领次数</th>
          <td>{{ couponInfo.perLimit }}</td>
        </tr>
        <tr>
          <th>领取数量</th>
          <td>{{ couponInfo.receiveCount }}</td>
          <th>使用数量</th>
          <td>{{ couponInfo.useCount }}</td>
        </tr>
        <tr>
          <th>领取时间</th>
          <td>{{ couponInfo.startTime }}至{{ couponInfo.endTime }}</td>
          <th>过期时间</th>
          <td>{{ couponInfo.expireTime }}</td>
        </tr>
        <tr>
          <th>规则描述</th>
          <td colspan="3">{{ couponInfo.ruleDesc }}</td>
        </tr>
      </tbody>
    </table>

    <h4>优惠券发放列表&nbsp;&nbsp;&nbsp;</h4>
    <el-table
      v-loading="listLoading"
      :data="list"
      stripe
      border
      style="width: 100%; margin-top: 10px"
    >
      <el-table-column label="序号" width="70" align="center">
        <template slot-scope="scope">
          {{ (page - 1) * limit + scope.$index + 1 }}
        </template>
      </el-table-column>
      <el-table-column prop="param.nickName" label="用户昵称" />
      <el-table-column prop="param.phone" label="手机号" />
      <el-table-column label="使用状态">
        <template slot-scope="scope">
          {{ scope.row.couponStatus == "NOT_USED" ? "未使用" : "已使用" }}
        </template>
      </el-table-column>
      <el-table-column prop="getTime" label="获取时间" />
      <el-table-column prop="usingTime" label="使用时间" />
      <el-table-column prop="usedTime" label="支付时间" />
      <el-table-column prop="expireTime" label="过期时间" />
    </el-table>

    <!-- 分页组件 -->
    <el-pagination
      :current-page="page"
      :total="total"
      :page-size="limit"
      :page-sizes="[5, 10, 20, 30, 40, 50, 100]"
      style="padding: 30px 0; text-align: center"
      layout="sizes, prev, pager, next, jumper, ->, total, slot"
      @current-change="fetchData"
      @size-change="changeSize"
    />

    <div style="margin-top: 15px">
      <el-form label-width="0px">
        <el-form-item>
          <el-button @click="back">返回</el-button>
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script>
  import couponInfoAPI from "@/api/activity/couponInfo";

  export default {
    data() {
      return {
        // 数据是否正在加载
        listLoading: false,
        couponId: null,
        couponInfo: {},
        // banner列表
        list: null,
        // 数据库中的总记录数
        total: 0,
        // 默认页码
        page: 1,
        // 每页记录数
        limit: 10,
        // 查询表单对象
        searchObj: {},
      };
    },

    // 监听器
    watch: {
      $route(to, from) {
        console.log("路由变化...");
        console.log(to);
        console.log(from);
        this.init();
      },
    },

    // 生命周期方法（在路由切换，组件不变的情况下不会被调用）
    created() {
      console.log("form created...");
      this.couponId = this.$route.params.id;
      // 获取优惠券信息
      this.fetchDataById();
      this.fetchData();
    },

    methods: {
      // 根据 id 查询记录
      fetchDataById() {
        couponInfoAPI.getById(this.couponId).then((response) => {
          this.couponInfo = response.data;
        });
      },

      // 当页码发生改变的时候
      changeSize(size) {
        console.log(size);
        this.limit = size;
        this.fetchData(1);
      },

      // 加载 banner 列表数据
      fetchData(page = 1) {
        console.log("翻页..." + page);
        // 异步获取远程数据（ajax）
        this.page = page;
        this.searchObj.couponId = this.couponId;
        couponInfoAPI
          .getPageCouponUseList(this.page, this.limit, this.searchObj)
          .then((response) => {
            this.list = response.data.records;
            this.total = response.data.total;

            // 数据加载并绑定成功
            this.listLoading = false;
          });
      },

      back() {
        this.$router.push({ path: "/activity/coupon/info/list" });
      },
    },
  };
</script>
```

### 二、微信公众号

#### 1、注册公众号

微信公众平台：https://mp.weixin.qq.com/

![注册公众号](https://img-blog.csdnimg.cn/44e6e57017554b45bd99b3ed0b78eda7.png)

硅谷课堂要求基于 H5，具有微信支付等高级功能的，因此需要注册服务号，订阅号不具备支付功能。

注册步骤参考官方注册文档：https://kf.qq.com/faq/120911VrYVrA151013MfYvYV.html

注册过程仅做了解，有公司运营负责申请与认证。

#### 2、公众号功能介绍

在微信公众平台扫码登录后可以发现管理页面左侧菜单栏有丰富的功能：

![公众号功能介绍](https://img-blog.csdnimg.cn/232908fe893d45b183b47acaf5e6a880.png)

大概可以分为这几大模块：

**首页**、**内容与互动**、**数据**、**广告与服务**、**设置与开发**、**新功能**

作为开发人员，首先应该关注的是设置与开发模块；而作为产品运营人员与数据分析人员，关注的是内容与互动、数据及广告与服务模块。

首先不妨各个功能模块都点击看一看，大概了解下能做些什么。可以确认的是，这个微信公众平台当然**不只是给开发人员使用**的，它提供了很多**非技术人员**可在**UI 界面上交互操作**的功能模块。

如配置消息回复、自定义菜单、发布文章等：

![公众号功能介绍](https://img-blog.csdnimg.cn/604a9ddb73c5462a94899ac16f9f241e.png)

这个时候可能会想：这些功能好像非技术人员都能随意操作，那么还需要技术人员去开发吗？

**答案是**： 如果只是日常简单的推送文章，就像关注的大多数公众号一样，那确实不需要技术人员去开发；但是，如果你想将你们的网站嵌入进去公众号菜单里（这里指的是把前端项目的首页链接配置在自定义菜单），并且实现微信端的独立登录认证、获取微信用户信息、微信支付等高级功能，或者觉得 UI 交互的配置方式无法满足你的需求，你需要更加自由、随心所欲的操作，那么就必须启用开发者模式了，通过技术人员的手段去灵活控制公众号。

**这里有一点需要注意，如果决定技术人员开发公众号，必须启用服务器配置，而这将导致 UI 界面设置的自动回复和自定义菜单失效！**

在 **设置与开发 - 基本配置 - 服务器配置** 中点击启用：

![公众号功能介绍](https://img-blog.csdnimg.cn/777815dcc40640ffa31686138453b769.png)

![公众号功能介绍](https://img-blog.csdnimg.cn/1f4e7cf131764bf48ecfa2f920acea78.png)

至于服务器配置中的选项代表什么意思、如何填写，下面再讲。

#### 3、微信公众平台测试帐号

##### 3.1、申请测试帐号

微信公众平台接口测试帐号：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&token=399029368&lang=zh_CN

![申请测试帐号](https://img-blog.csdnimg.cn/b34c075a88a341f6aa0c8fbe083d7392.png)

![申请测试帐号](https://img-blog.csdnimg.cn/0006d53a2e6442778545f32e52550696.png)

##### 3.2、查看测试号管理

（1）其中 appID 和 appsecret 用于后面菜单开发使用。

（2）其中 URL 是开发者用来接收微信消息和事件的接口 URL。Token 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。本地测试，url 改为内网穿透地址。

![查看测试号管理](https://img-blog.csdnimg.cn/7da2d419fc9f4221b04d61ccdb373eb6.png)

##### 3.3、关注公众号

![关注公众号](https://img-blog.csdnimg.cn/27de9b9657194c4e96c367e90d01cda6.png)

![关注公众号](https://img-blog.csdnimg.cn/0b5d5b72f00b40f2a546a0c57d25658d.png)

#### 4、开发业务介绍

硅谷课堂涉及的微信公众号功能模块：自定义菜单、消息、微信支付、授权登录等。

### 三、后台管理系统-公众号菜单管理

#### 1、需求分析

##### 1.1、微信自定义菜单说明

微信自定义菜单文档地址：https://developers.weixin.qq.com/doc/offiaccount/Custom_Menus/Creating_Custom-Defined_Menu.html

微信自定义菜单注意事项：

1. 自定义菜单最多包括 3 个一级菜单，每个一级菜单最多包含 5 个二级菜单。

2. 一级菜单最多 4 个汉字，二级菜单最多 8 个汉字，多出来的部分将会以“...”代替。

3. 创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号 profile 页时，如果发现上一次拉取菜单的请求在 5 分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。

##### 1.2、硅谷课堂自定义菜单

一级菜单：直播、课程、我的。

二级菜单：根据一级菜单动态设置二级菜单，直播（近期直播课程），课程（课程分类），我的（我的订单、我的课程、我的优惠券以及关于我们）。

说明：

​ 1、二级菜单可以是网页类型，点击跳转 H5 页面。

​ 2、二级菜单可以是消息类型，点击返回消息。

##### 1.3、数据格式

自定义菜单通过后台管理设置到数据库表，数据配置好后，通过微信接口推送菜单数据到微信平台。

**表结构（menu）：**

![数据格式](https://img-blog.csdnimg.cn/00ce62757c13457daa949c500c3d9fb9.png)

![数据格式](https://img-blog.csdnimg.cn/555d17bf9fdc4762b948afa040938fc7.png)

表示例数据：

![数据格式](https://img-blog.csdnimg.cn/89f859c3176145378bd6ff2814b32237.png)

##### 1.4、管理页面

**（1）页面功能“列表、添加、修改与删除”是对 menu 表的操作。**

**（2）页面功能“同步菜单与删除菜单”是对微信平台接口操作。**

![管理页面](https://img-blog.csdnimg.cn/efaac38102474157b35dd9c5d85bd1c2.png)

#### 2、搭建菜单管理后端环境

##### 2.1、创建模块 service-wechat

**（1）在 service 下创建子模块 service-wechat。**

![创建模块 service-wechat](https://img-blog.csdnimg.cn/c1a24355764a4c9cbb5b70944907997a.png)

**（2）引入依赖。**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.myxh.smart.planet</groupId>
        <artifactId>service</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>service-wechat</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- mybatis-plus-generator -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
            <version>3.5.3.1</version>
        </dependency>

        <!-- freemarker -->
        <dependency>
            <groupId>org.freemarker</groupId>
            <artifactId>freemarker</artifactId>
            <version>2.3.32</version>
        </dependency>

        <!-- weixin-java-mp -->
        <dependency>
            <groupId>com.github.binarywang</groupId>
            <artifactId>weixin-java-mp</artifactId>
            <version>4.5.0</version>
        </dependency>
    </dependencies>
</project>
```

##### 2.2、生成菜单相关代码

![生成菜单相关代码](https://img-blog.csdnimg.cn/cfaeb606e2f14d46b5a3359b4b171ac9.png)

##### 2.3、创建启动类和配置文件

**（1）启动类。**

```java
package com.myxh.smart.planet.wechat;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

/**
 * @author MYXH
 * @date 2023/10/16
 */
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients(basePackages = "com.myxh.smart.planet")
@MapperScan("com.myxh.smart.planet.wechat.mapper")
public class ServiceWechatApplication
{
    public static void main(String[] args)
    {
        SpringApplication.run(ServiceWechatApplication.class, args);
    }
}
```

**（2）配置文件。**

```properties
# 服务端口
server.port=8305

# 服务名
spring.application.name=service-wechat

# 环境设置：dev、test、prod
spring.profiles.active=dev

# MySQL 数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/smart_planet_wechat?characterEncoding=utf-8&useSSL=false
spring.datasource.username=MYXH
spring.datasource.password=520.ILY!

# 返回 Json 的全局时间格式
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8

# MyBatis 日志
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 设置 mapper.xml 的路径
mybatis-plus.mapper-locations=classpath:com/myxh/smart/planet/wechat/mapper/xml/*.xml

# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

# 公众号 id 和秘钥
# 智慧星球微信公众平台 appId
wechat.appId=wxc23b80b9ffaac7bd
# 智慧星球微信公众平台 api 秘钥
wechat.appSecret=5c0271622c4271753310c436b5cd3532
```

##### 2.4、配置网关

```properties
# service-wechat 模块配置
# 设置路由 id
spring.cloud.gateway.routes[4].id=service-wechat
# 设置路由的 uri，lb 全称为 Load Balance 负载平衡
spring.cloud.gateway.routes[4].uri=lb://service-wechat
# 设置路由断言,代理 servicerId 为 auth-service 的 /auth/ 路径，/admin/wechat/menu
spring.cloud.gateway.routes[4].predicates= Path=/*/wechat/**
```

#### 3、开发菜单管理接口

##### 3.1、编写 MenuController

```java
package com.myxh.smart.planet.wechat.controller;

import com.myxh.smart.planet.model.wechat.Menu;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.vo.wechat.MenuVo;
import com.myxh.smart.planet.wechat.service.MenuService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 前端控制器
 * </p>
 */
@Tag(name = "微信公众号菜单管理", description = "微信公众号菜单管理接口")
@RestController
@RequestMapping("/admin/wechat/menu")
public class MenuController
{
    @Autowired
    private MenuService menuService;

    /**
     * 获取所有菜单，按照一级和二级菜单封装
     *
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "获取所有菜单", description = "获取所有菜单，按照一级和二级菜单封装")
    @GetMapping("find/menu/info")
    public Result<List<MenuVo>> findMenuInfo()
    {
        List<MenuVo> menuList = menuService.findMenuInfo();

        return Result.ok(menuList);
    }

    /**
     * 获取所有一级菜单
     *
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "获取所有一级菜单", description = "获取所有一级菜单")
    @GetMapping("find/one/menu/info")
    public Result<List<Menu>> findOneMenuInfo()
    {
        List<Menu> oneMenuList = menuService.findMenuOneInfo();

        return Result.ok(oneMenuList);
    }

    /**
     * 根据 id 查询菜单
     *
     * @param id id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "查询", description = "根据 id 查询菜单")
    @GetMapping("get/{id}")
    public Result<Menu> get(@PathVariable("id") Long id)
    {
        Menu menu = menuService.getById(id);

        return Result.ok(menu);
    }

    /**
     * 添加菜单
     *
     * @param menu 菜单
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "添加", description = "添加菜单")
    @PostMapping("save")
    public Result<Void> save(@RequestBody Menu menu)
    {
        menuService.save(menu);

        return Result.ok(null);
    }

    /**
     * 修改菜单
     *
     * @param menu 菜单
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "修改", description = "修改菜单")
    @PutMapping("update")
    public Result<Void> updateById(@RequestBody Menu menu)
    {
        menuService.updateById(menu);

        return Result.ok(null);
    }

    /**
     * 逻辑删除菜单
     *
     * @param id id
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除", description = "逻辑删除菜单")
    @DeleteMapping("remove/{id}")
    public Result<Void> remove(@PathVariable("id") Long id)
    {
        menuService.removeById(id);

        return Result.ok(null);
    }

    /**
     * 批量删除菜单
     *
     * @param idList id 数组，Json 数组 [1,2,3,...]
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "批量删除", description = "批量删除菜单")
    @DeleteMapping("remove/batch")
    public Result<Void> batchRemove(@RequestBody List<Long> idList)
    {
        menuService.removeByIds(idList);

        return Result.ok(null);
    }
}
```

##### 3.2、编写 Service

**（1）MenuService 定义方法。**

```java
package com.myxh.smart.planet.wechat.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.myxh.smart.planet.model.wechat.Menu;
import com.myxh.smart.planet.vo.wechat.MenuVo;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 服务类
 * </p>
 */
public interface MenuService extends IService<Menu>
{
    /**
     * 获取所有菜单，按照一级和二级菜单封装
     *
     * @return menuList 菜单列表
     */
    List<MenuVo> findMenuInfo();

    /**
     * 获取所有一级菜单
     *
     * @return oneMenuList 一级菜单列表
     */
    List<Menu> findMenuOneInfo();
}
```

**（2）MenuServiceImpl 实现方法。**

```java
package com.myxh.smart.planet.wechat.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.wechat.Menu;
import com.myxh.smart.planet.vo.wechat.MenuVo;
import com.myxh.smart.planet.wechat.mapper.MenuMapper;
import com.myxh.smart.planet.wechat.service.MenuService;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 服务实现类
 * </p>
 */
@Service
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu> implements MenuService
{
    /**
     * 获取所有菜单，按照一级和二级菜单封装
     *
     * @return menuList 菜单列表
     */
    @Override
    public List<MenuVo> findMenuInfo()
    {
        // 1、创建 List 集合，用于最终数据封装
        List<MenuVo> finalMenuList = new ArrayList<>();

        // 2、查询所有菜单数据（包含一级和二级）
        List<Menu> menuList = baseMapper.selectList(null);

        // 3、从所有菜单数据获取所有一级菜单数据（parentId = 0）
        List<Menu> oneMenuList = menuList.stream().filter(menu -> menu.getParentId() == 0).toList();

        // 4、封装一级菜单数据，封装到最终数据 List 集台
        // 遍历一级菜单 List 集合
        for (Menu oneMenu : oneMenuList)
        {
            MenuVo oneMenuVo = new MenuVo();
            BeanUtils.copyProperties(oneMenu, oneMenuVo);

            // 5、封装二级菜单数据（判断一级菜单和二级菜单 parentId是否相同）
            // 如果相同，把二级菜单数据放到一级菜单里面
            List<Menu> twoMenuList = menuList.stream().filter(menu -> menu.getParentId().longValue() == oneMenu.getId()).sorted(Comparator.comparing(Menu::getSort)).toList();

            List<MenuVo> children = new ArrayList<>();

            for (Menu twoMenu : twoMenuList)
            {
                MenuVo twoMenuVo = new MenuVo();
                BeanUtils.copyProperties(twoMenu, twoMenuVo);
                children.add(twoMenuVo);
            }

            // 把二级菜单数据放到一级菜单里面
            oneMenuVo.setChildren(children);

            // 把 oneMenuVo 放到最终 List 集合
            finalMenuList.add(oneMenuVo);
        }

        // 返回最终数据
        return finalMenuList;
    }

    /**
     * 获取所有一级菜单
     *
     * @return oneMenuList 一级菜单列表
     */
    @Override
    public List<Menu> findMenuOneInfo()
    {
        QueryWrapper<Menu> wrapper = new QueryWrapper<>();
        wrapper.eq("parent_id", 0);
        List<Menu> oneMenuList = baseMapper.selectList(wrapper);

        return oneMenuList;
    }
}
```

#### 4、同步菜单（获取 access_token）

##### 4.1、文档查看

**（1）进行菜单同步时候，需要获取到公众号的 access_token，通过 access_token 进行菜单同步。**

接口文档：https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html

![文档查看](https://img-blog.csdnimg.cn/d6321cdcaea04ba891d4e00815694b4d.png)

**（2）调用方式。**

![文档查看](https://img-blog.csdnimg.cn/a701e1781f0a49b4a5f4caaf0ccd652a.png)

![文档查看](https://img-blog.csdnimg.cn/0347658c163d417b9271140015521151.png)

##### 4.2、service-wechat 添加配置

```properties
# 公众号 id 和秘钥
# 智慧星球微信公众平台 appId
wechat.appId=wxc23b80b9ffaac7bd
# 智慧星球微信公众平台 api 秘钥
wechat.appSecret=5c0271622c4271753310c436b5cd3532
```

##### 4.3、添加工具类

```java
package com.myxh.smart.planet.wechat.utils;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * @author MYXH
 * @date 2023/10/17
 * @description 常量类，读取配置文件 application.properties 中的配置
 */
@Component
public class ConstantPropertiesUtil implements InitializingBean
{
    @Value("${wechat.appId}")
    private String appId;

    @Value("${wechat.appSecret}")
    private String appSecret;

    public static String ACCESS_KEY_ID;
    public static String ACCESS_KEY_SECRET;

    @Override
    public void afterPropertiesSet() throws Exception
    {
        ACCESS_KEY_ID = appId;
        ACCESS_KEY_SECRET = appSecret;
    }
}
```

##### 4.4、复制 HttpClient 工具类

![复制 HttpClient 工具类](https://img-blog.csdnimg.cn/ac9b5781a2aa4a8980932c536408c2ff.png)

##### 4.5、添加 Menucontroller 方法

```java
package com.myxh.smart.planet.wechat.controller;

import com.alibaba.fastjson2.JSONObject;
import com.myxh.smart.planet.exception.SmartPlanetException;
import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.wechat.utils.ConstantPropertiesUtil;
import com.myxh.smart.planet.wechat.utils.HttpClientUtils;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 前端控制器
 * </p>
 */
@Tag(name = "微信公众号菜单管理", description = "微信公众号菜单管理接口")
@RestController
@RequestMapping("/admin/wechat/menu")
public class MenuController
{
    /**
     * 获取 access_token
     *
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "获取 access_token", description = "获取 access_token")
    @GetMapping("get/access/token")
    public Result<String> getAccessToken()
    {
        try
        {
            // 拼接请求地址
            String buffer = "https://api.weixin.qq.com/cgi-bin/token" +
                    "?grant_type=client_credential" +
                    "&appid=%s" +
                    "&secret=%s";

            // 请求地址设置参数
            String url = String.format(buffer,
                    ConstantPropertiesUtil.ACCESS_KEY_ID,
                    ConstantPropertiesUtil.ACCESS_KEY_SECRET);

            // 发送 http 请求
            String tokenString = HttpClientUtils.get(url);

            // 获取 access_token
            JSONObject jsonObject = JSONObject.parseObject(tokenString);
            String access_token = jsonObject.getString("access_token");

            // 返回
            return Result.ok(access_token);
        }
        catch (Exception e)
        {
            e.printStackTrace();

            throw new SmartPlanetException(20001, "获取 access_token 失败");
        }
    }
}
```

##### 4.6、测试

#### 5、同步菜单（功能实现）

接口文档：https://developers.weixin.qq.com/doc/offiaccount/Custom_Menus/Creating_Custom-Defined_Menu.html

**接口调用请求说明：**

http 请求方式：POST（请使用 https 协议） https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN

**weixin-java-mp**是封装好了的微信接口客户端，使用起来很方便，后续就使用 weixin-java-mp 处理微信平台接口。

##### 5.1、添加配置类

```java
package com.myxh.smart.planet.wechat.config;

import com.myxh.smart.planet.wechat.utils.ConstantPropertiesUtil;
import me.chanjar.weixin.mp.api.WxMpService;
import me.chanjar.weixin.mp.api.impl.WxMpServiceImpl;
import me.chanjar.weixin.mp.config.WxMpConfigStorage;
import me.chanjar.weixin.mp.config.impl.WxMpDefaultConfigImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@Component
public class WeChatMpConfig
{

    @Autowired
    public WeChatMpConfig(ConstantPropertiesUtil constantPropertiesUtil)
    {

    }

    @Bean
    public WxMpService wxMpService(WxMpConfigStorage wxMpConfigStorage)
    {
        WxMpService wxMpService = new WxMpServiceImpl();
        wxMpService.setWxMpConfigStorage(wxMpConfigStorage);

        return wxMpService;
    }

    @Bean
    public WxMpConfigStorage wxMpConfigStorage()
    {
        WxMpDefaultConfigImpl wxMpConfigStorage = new WxMpDefaultConfigImpl();
        wxMpConfigStorage.setAppId(ConstantPropertiesUtil.ACCESS_KEY_ID);
        wxMpConfigStorage.setSecret(ConstantPropertiesUtil.ACCESS_KEY_SECRET);

        return wxMpConfigStorage;
    }
}
```

##### 5.2、定义 Service 方法

**MenuService**

```java
package com.myxh.smart.planet.wechat.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.myxh.smart.planet.model.wechat.Menu;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 服务类
 * </p>
 */
public interface MenuService extends IService<Menu>
{
    /**
     * 同步微信公众号菜单
     */
    void syncMenu();
}
```

##### 5.3、实现 Service 方法

**MenuServiceImpl**

```java
package com.myxh.smart.planet.wechat.service.impl;

import com.alibaba.fastjson2.JSONArray;
import com.alibaba.fastjson2.JSONObject;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.exception.SmartPlanetException;
import com.myxh.smart.planet.model.wechat.Menu;
import com.myxh.smart.planet.vo.wechat.MenuVo;
import com.myxh.smart.planet.wechat.mapper.MenuMapper;
import com.myxh.smart.planet.wechat.service.MenuService;
import lombok.SneakyThrows;
import me.chanjar.weixin.mp.api.WxMpService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 服务实现类
 * </p>
 */
@Service
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu> implements MenuService
{
    @Autowired
    private WxMpService wxMpService;

    /**
     * 同步微信公众号菜单
     */
    @SneakyThrows
    @Override
    public void syncMenu()
    {
        // 获取所有菜单数据
        List<MenuVo> menuVoList = this.findMenuInfo();

        // 封装 button 里面结构，数组格式
        JSONArray buttonList = new JSONArray();

        for (MenuVo oneMenuVo : menuVoList)
        {
            // json 对象，一级菜单
            JSONObject one = new JSONObject();
            one.put("name", oneMenuVo.getName());

            // json 数组，二级菜单
            JSONArray subButton = new JSONArray();

            for (MenuVo twoMenuVo : oneMenuVo.getChildren())
            {
                JSONObject view = new JSONObject();
                view.put("type", twoMenuVo.getType());
                view.put("name", twoMenuVo.getName());

                if (twoMenuVo.getType().equals("view"))
                {
                    view.put("url", "http://smartplanetmobile.free.idcfengye.com/#" + twoMenuVo.getUrl());
                }
                else
                {
                    view.put("key", twoMenuVo.getMenuKey());
                }

                subButton.add(view);
            }

            one.put("sub_button", subButton);
            buttonList.add(one);
        }

        // 封装最外层 button 部分
        JSONObject button = new JSONObject();
        button.put("button", buttonList);

        try
        {
            String menuId = this.wxMpService.getMenuService().menuCreate(button.toJSONString());
            System.out.println("menuId = " + menuId);

        }
        catch (Exception e)
        {
            throw new SmartPlanetException(20001, "微信公众号菜单同步失败");
        }
    }
}
```

##### 5.4、controller 方法

```java
package com.myxh.smart.planet.wechat.controller;

import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.wechat.service.MenuService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 前端控制器
 * </p>
 */
@Tag(name = "微信公众号菜单管理", description = "微信公众号菜单管理接口")
@RestController
@RequestMapping("/admin/wechat/menu")
public class MenuController
{
    @Autowired
    private MenuService menuService;

    /**
     * 同步微信公众号菜单
     *
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "同步微信公众号菜单", description = "同步微信公众号菜单")
    @GetMapping("sync/menu")
    public Result<Void> createMenu()
    {
        menuService.syncMenu();

        return Result.ok(null);
    }
}
```

#### 6、删除菜单

##### 6.1、service 接口

```java
package com.myxh.smart.planet.wechat.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.myxh.smart.planet.model.wechat.Menu;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 服务类
 * </p>
 */
public interface MenuService extends IService<Menu>
{
    /**
     * 删除微信公众号菜单
     */
    void removeMenu();
}
```

##### 6.2、service 接口实现

```java
package com.myxh.smart.planet.wechat.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.exception.SmartPlanetException;
import com.myxh.smart.planet.model.wechat.Menu;
import com.myxh.smart.planet.wechat.mapper.MenuMapper;
import com.myxh.smart.planet.wechat.service.MenuService;
import me.chanjar.weixin.common.error.WxErrorException;
import me.chanjar.weixin.mp.api.WxMpService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 服务实现类
 * </p>
 */
@Service
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu> implements MenuService
{
    @Autowired
    private WxMpService wxMpService;

    /**
     * 删除微信公众号菜单
     */
    @Override
    public void removeMenu()
    {
        try
        {
            wxMpService.getMenuService().menuDelete();
        }
        catch (WxErrorException e)
        {
            throw new SmartPlanetException(20001, "微信公众号菜单删除失败");
        }
    }
}
```

##### 6.3、controller 方法

```java
package com.myxh.smart.planet.wechat.controller;

import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.wechat.service.MenuService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author MYXH
 * @date 2023/10/16
 *
 * <p>
 * 菜单 前端控制器
 * </p>
 */
@Tag(name = "微信公众号菜单管理", description = "微信公众号菜单管理接口")
@RestController
@RequestMapping("/admin/wechat/menu")
public class MenuController
{
    @Autowired
    private MenuService menuService;

    /**
     * 删除微信公众号菜单
     *
     * @return Result 全局统一返回结果
     */
    @Operation(summary = "删除微信公众号菜单", description = "删除微信公众号菜单")
    @DeleteMapping("remove/menu")
    public Result<Void> removeMenu()
    {
        menuService.removeMenu();

        return Result.ok(null);
    }
}
```

#### 7、开发菜单管理前端

##### 7.1、添加路由

**（1）src/router/index.js 添加路由。**

```javascript
// 微信公众号菜单管理
{
  path: "/wechat",
  component: Layout,
  redirect: "/wechat/menu/list",
  name: "Wechat",
  meta: {
    title: "微信公众号菜单管理",
    icon: "el-icon-refrigerator",
  },
  alwaysShow: true,
  children: [
    {
      path: "menu/list",
      name: "Menu",
      component: () => import("@/views/wechat/menu/list"),
      meta: { title: "菜单列表" },
    },
  ],
},
```

##### 7.2、定义接口

**（1）src/api/wechat/menu.js 定义接口。**

```javascript
import request from "@/utils/request";

const MENU_API = "/admin/wechat/menu";

export default {
  /**
   * 获取所有菜单，按照一级和二级菜单封装
   *
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  findMenuInfo() {
    return request({
      url: `${MENU_API}/find/menu/info`,
      method: `get`,
    });
  },

  /**
   * 获取所有一级菜单
   *
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  findOneMenuInfo() {
    return request({
      url: `${MENU_API}/find/one/menu/info`,
      method: `get`,
    });
  },

  /**
   * 根据 id 查询菜单
   *
   * @param {number} id id
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  getById(id) {
    return request({
      url: `${MENU_API}/get/${id}`,
      method: `get`,
    });
  },

  /**
   * 添加菜单
   *
   * @param {Object} menu 菜单
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  save(menu) {
    return request({
      url: `${MENU_API}/save`,
      method: `post`,
      data: menu,
    });
  },

  /**
   * 修改菜单
   *
   * @param {Object} menu 菜单
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  updateById(menu) {
    return request({
      url: `${MENU_API}/update`,
      method: `put`,
      data: menu,
    });
  },

  /**
   * 逻辑删除菜单
   *
   * @param {number} id id
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  removeById(id) {
    return request({
      url: `${MENU_API}/remove/${id}`,
      method: "delete",
    });
  },

  /**
   * 同步微信公众号菜单
   *
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  syncMenu() {
    return request({
      url: `${MENU_API}/sync/menu`,
      method: `get`,
    });
  },

  /**
   * 删除微信公众号菜单
   *
   * @returns {Promise} 返回一个 Promise 对象，表示操作的异步结果
   */
  removeMenu() {
    return request({
      url: `${MENU_API}/remove/menu`,
      method: `delete`,
    });
  },
};
```

##### 7.3、编写页面

**（1）创建 views/wechat/menu/list.vue。**

```html
<template>
  <div class="app-container">
    <!-- 工具条 -->
    <el-card class="operate-container" shadow="never">
      <i class="el-icon-tickets" style="margin-top: 5px"></i>
      <span style="margin-top: 5px">数据列表</span>
      <el-button
        class="btn-add"
        size="mini"
        @click="removeMenu"
        style="margin-left: 10px"
        >删除菜单</el-button
      >
      <el-button class="btn-add" size="mini" @click="syncMenu"
        >同步菜单</el-button
      >
      <el-button class="btn-add" size="mini" @click="add">添 加</el-button>
    </el-card>

    <el-table
      :data="list"
      style="width: 100%; margin-bottom: 20px"
      row-key="id"
      border
      default-expand-all
      :tree-props="{ children: 'children' }"
    >
      <el-table-column label="名称" prop="name" width="350"></el-table-column>
      <el-table-column label="类型" width="100">
        <template slot-scope="scope">
          {{ scope.row.type === "view" ? "链接" : scope.row.type == "click" ?
          "事件" : "" }}
        </template>
      </el-table-column>
      <el-table-column label="菜单URL" prop="url"></el-table-column>
      <el-table-column
        label="菜单KEY"
        prop="menuKey"
        width="130"
      ></el-table-column>
      <el-table-column label="排序号" prop="sort" width="70"></el-table-column>
      <el-table-column label="操作" width="170" align="center">
        <template slot-scope="scope">
          <el-button
            v-if="scope.row.parentId > 0"
            type="text"
            size="mini"
            @click="edit(scope.row.id)"
            >修改</el-button
          >
          <el-button
            v-if="scope.row.parentId > 0"
            type="text"
            size="mini"
            @click="removeDataById(scope.row.id)"
            >删除</el-button
          >
        </template>
      </el-table-column>
    </el-table>

    <el-dialog title="添加/修改" :visible.sync="dialogVisible" width="40%">
      <el-form
        ref="flashPromotionForm"
        label-width="150px"
        size="small"
        style="padding-right: 40px"
      >
        <el-form-item label="选择一级菜单">
          <el-select v-model="menu.parentId" placeholder="请选择">
            <el-option
              v-for="item in list"
              :key="item.id"
              :label="item.name"
              :value="item.id"
            />
          </el-select>
        </el-form-item>
        <el-form-item v-if="menu.parentId == 1" label="菜单名称">
          <el-select
            v-model="menu.name"
            placeholder="请选择"
            @change="liveCourseChanged"
          >
            <el-option
              v-for="item in liveCourseList"
              :key="item.id"
              :label="item.courseName"
              :value="item"
            />
          </el-select>
        </el-form-item>
        <el-form-item v-if="menu.parentId == 2" label="菜单名称">
          <el-select
            v-model="menu.name"
            placeholder="请选择"
            @change="subjectChanged"
          >
            <el-option
              v-for="item in subjectList"
              :key="item.id"
              :label="item.title"
              :value="item"
            />
          </el-select>
        </el-form-item>
        <el-form-item v-if="menu.parentId == 3" label="菜单名称">
          <el-input v-model="menu.name" />
        </el-form-item>
        <el-form-item label="菜单类型">
          <el-radio-group v-model="menu.type">
            <el-radio label="view">链接</el-radio>
            <el-radio label="click">事件</el-radio>
          </el-radio-group>
        </el-form-item>
        <el-form-item v-if="menu.type == 'view'" label="链接">
          <el-input v-model="menu.url" />
        </el-form-item>
        <el-form-item v-if="menu.type == 'click'" label="菜单KEY">
          <el-input v-model="menu.menuKey" />
        </el-form-item>
        <el-form-item label="排序">
          <el-input v-model="menu.sort" />
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false" size="small">取 消</el-button>
        <el-button type="primary" @click="saveOrUpdate()" size="small"
          >确 定</el-button
        >
      </span>
    </el-dialog>
  </div>
</template>

<script>
  import menuAPI from "@/api/wechat/menu";
  // import liveCourseAPI from '@/api/live/liveCourse'
  import subjectAPI from "@/api/vod/subject";

  const defaultForm = {
    id: null,
    parentId: 1,
    name: "",
    nameId: null,
    sort: 1,
    type: "view",
    menuKey: "",
    url: "",
  };

  export default {
    // 定义数据
    data() {
      return {
        list: [],
        liveCourseList: [],
        subjectList: [],
        dialogVisible: false,
        menu: defaultForm,
        saveBtnDisabled: false,
      };
    },

    // 当页面加载时获取数据
    created() {
      this.fetchData();
      // this.fetchLiveCourse()
      this.fetchSubject();
    },

    methods: {
      // 调用 api 层获取数据库中的数据
      fetchData() {
        console.log("加载列表");
        menuAPI.findMenuInfo().then((response) => {
          this.list = response.data;
          console.log(this.list);
        });
      },

      /*
    fetchLiveCourse() {
      liveCourseAPI.findLatelyList().then((response) => {
        this.liveCourseList = response.data;
        this.liveCourseList.push({ id: 0, courseName: "全部列表" });
      });
    },
     */

      fetchSubject() {
        console.log("加载列表");
        subjectAPI.getChildList(0).then((response) => {
          this.subjectList = response.data;
        });
      },

      syncMenu() {
        this.$confirm("你确定上传菜单吗, 是否继续?", "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning",
        })
          .then(() => {
            return menuAPI.syncMenu();
          })
          .then((response) => {
            this.fetchData();
            this.$message.success(response.message);
          })
          .catch((error) => {
            console.log("error", error);
            // 当取消时会进入 catch 语句:error = 'cancel'
            // 当后端服务抛出异常时：error = 'error'
            if (error === "cancel") {
              this.$message.info("取消上传");
            }
          });
      },

      removeMenu() {
        this.$confirm("你确定删除菜单吗, 是否继续?", "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning",
        })
          .then(() => {
            return menuAPI.removeMenu();
          })
          .then((response) => {
            this.fetchData();
            this.$message.success(response.message);
          })
          .catch((error) => {
            console.log("error", error);
            // 当取消时会进入 catch 语句:error = 'cancel'
            // 当后端服务抛出异常时：error = 'error'
            if (error === "cancel") {
              this.$message.info("取消删除");
            }
          });
      },

      // 根据 id 删除数据
      removeDataById(id) {
        this.$confirm("此操作将永久删除该记录, 是否继续?", "提示", {
          confirmButtonText: "确定",
          cancelButtonText: "取消",
          type: "warning",
        })
          .then(() => {
            // 点击确定，远程调用 ajax
            return menuAPI.removeById(id);
          })
          .then((response) => {
            this.fetchData(this.page);
            if (response.code) {
              this.$message({
                type: "success",
                message: "删除成功!",
              });
            }
          })
          .catch(() => {
            this.$message({
              type: "info",
              message: "已取消删除",
            });
          });
      },

      add() {
        this.dialogVisible = true;
        this.menu = Object.assign({}, defaultForm);
      },

      edit(id) {
        this.dialogVisible = true;
        this.fetchDataById(id);
      },

      fetchDataById(id) {
        menuAPI.getById(id).then((response) => {
          this.menu = response.data;
        });
      },

      saveOrUpdate() {
        // 防止表单重复提交
        this.saveBtnDisabled = true;

        if (!this.menu.name) {
          this.$message.error("请输入菜单名称");
          this.saveBtnDisabled = false;
          return;
        }

        if (!this.menu.id) {
          this.saveData();
        } else {
          this.updateData();
        }
      },

      // 新增
      saveData() {
        menuAPI.save(this.menu).then((response) => {
          if (response.code) {
            this.$message({
              type: "success",
              message: response.message,
            });
            this.dialogVisible = false;
            this.fetchData(this.page);
          }
        });
      },

      // 根据 id 更新记录
      updateData() {
        menuAPI.updateById(this.menu).then((response) => {
          if (response.code) {
            this.$message({
              type: "success",
              message: response.message,
            });
            this.dialogVisible = false;
            this.fetchData(this.page);
          }
        });
      },

      // 根据 id 查询记录
      fetchDataById(id) {
        menuAPI.getById(id).then((response) => {
          this.menu = response.data;
        });
      },

      subjectChanged(item) {
        console.info(item);
        this.menu.name = item.title;
        this.menu.url = "/course/" + item.id;
      },

      liveCourseChanged(item) {
        console.info(item);
        this.menu.name = item.courseName;
        if (item.id == 0) {
          this.menu.url = "/live";
        } else {
          this.menu.url = "/live/info/" + item.id;
        }
      },
    },
  };
</script>
```

#### 8、公众号菜单功能测试

**（1）在手机公众号可以看到同步之后的菜单。**

![公众号菜单功能测试](https://img-blog.csdnimg.cn/18c9feef63ee4b3bb92da9d677bed4df.png)

## Day 12-公众号消息和微信授权登录

### 一、公众号普通消息

#### 1、实现目标

1、“智慧星球”公众号实现根据关键字搜索相关课程，如：输入“Java”，可返回 Java 相关的一个课程。

2、“智慧星球”公众号点击菜单“关于我们”，返回关于我们的介绍。

3、关注或取消关注等。

#### 2、消息接入

参考文档：https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html

接入微信公众平台开发，开发者需要按照如下步骤完成：

1、填写服务器配置。

2、验证服务器地址的有效性。

3、依据接口文档实现业务逻辑。

##### 2.1、公众号服务器配置

在测试管理 -> 接口配置信息，点击“修改”按钮，填写服务器地址（URL）和 Token，其中 URL 是开发者用来接收微信消息和事件的接口 URL。Token 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。

说明：本地测试，url 改为内网穿透地址。

![公众号服务器配置](https://img-blog.csdnimg.cn/cb1d5126ca044b09b7f3840b14b34364.png)

##### 2.2、验证来自微信服务器消息

**（1）概述。**

开发者提交信息后，微信服务器将发送 GET 请求到填写的服务器地址 URL 上，GET 请求携带参数如下表所示：

| 参数      | 描述                                                                                         |
| :-------- | :------------------------------------------------------------------------------------------- |
| signature | 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数。 |
| timestamp | 时间戳。                                                                                     |
| nonce     | 随机数。                                                                                     |
| echostr   | 随机字符串。                                                                                 |

开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

1、将 token、timestamp、nonce 三个参数进行字典序排序。

2、将三个参数字符串拼接成一个字符串进行 sha1 加密。

3、开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信。

**（2）代码实现。**

**创建 MessageController。**

```java
package com.myxh.smart.planet.wechat.controller;

import com.myxh.smart.planet.wechat.utils.SHA1;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Arrays;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@RestController
@RequestMapping("/api/wechat/message")
public class MessageController
{
    private static final String token = "SmartPlanet";

    /**
     * 服务器有效性验证
     *
     * @param request 请求
     * @return echostr 随机字符串
     */
    @GetMapping
    public String verifyToken(HttpServletRequest request)
    {
        String signature = request.getParameter("signature");
        String timestamp = request.getParameter("timestamp");
        String nonce = request.getParameter("nonce");
        String echostr = request.getParameter("echostr");

        System.out.println("signature: " + signature + " nonce: " + nonce + " echostr: " + echostr + "timestamp: " + timestamp);

        if (this.checkSignature(signature, timestamp, nonce))
        {
            System.out.println("token ok");

            return echostr;
        }

        return echostr;
    }

    private boolean checkSignature(String signature, String timestamp, String nonce)
    {
        String[] str = new String[]{token, timestamp, nonce};

        // 排序
        Arrays.sort(str);

        // 拼接字符串
        StringBuilder buffer = new StringBuilder();

        for (String s : str)
        {
            buffer.append(s);
        }

        // 进行 SHA1 加密
        String temp = SHA1.encode(buffer.toString());

        // 与微信提供的 signature 进行匹对
        return signature.equals(temp);
    }
}
```

完成之后，校验接口就算是开发完成了。接下来就可以开发消息接收接口了。

##### 2.3、消息接收

接下来开发消息接收接口，消息接收接口和上面的服务器校验接口地址是一样的，都是一开始在公众号后台配置的地址。只不过消息接收接口是一个 POST 请求。

在公众号后台配置的时候，消息加解密方式选择了明文模式，这样在后台收到的消息直接就可以处理了。微信服务器给我发来的普通文本消息格式如下：

```xml
<xml>
    <ToUserName><![CDATA[toUser]]></ToUserName>
    <FromUserName><![CDATA[fromUser]]></FromUserName>
    <CreateTime>1348831860</CreateTime>
    <MsgType><![CDATA[text]]></MsgType>
    <Content><![CDATA[this is a test]]></Content>
    <MsgId>1234567890123456</MsgId>
    <MsgDataId>xxxx</MsgDataId>
    <Idx>xxxx</Idx>
</xml>
```

| 参数         | 描述                                                      |
| ------------ | --------------------------------------------------------- |
| ToUserName   | 开发者微信号。                                            |
| FromUserName | 发送方帐号（一个 OpenID）。                               |
| CreateTime   | 消息创建时间（整型）。                                    |
| MsgType      | 消息类型，文本为 text。                                   |
| Content      | 文本消息内容。                                            |
| MsgId        | 消息 id，64 位整型。                                      |
| MsgDataId    | 消息的数据 ID（消息如果来自文章时才有）。                 |
| Idx          | 多图文时第几篇文章，从 1 开始（消息如果来自文章时才有）。 |

看到这里，心里大概就有数了，当收到微信服务器发来的消息之后，就进行 XML 解析，提取出来需要的信息，去做相关的查询操作，再将查到的结果返回给微信服务器。

这里先来个简单的，将收到的消息解析并打印出来：

```java
package com.myxh.smart.planet.wechat.controller;

import com.alibaba.fastjson2.JSONObject;
import jakarta.servlet.http.HttpServletRequest;
import me.chanjar.weixin.mp.bean.message.WxMpXmlMessage;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@RestController
@RequestMapping("/api/wechat/message")
public class MessageController
{
    /**
     * 接收微信服务器发送来的消息
     *
     * @param request 请求
     * @return message 消息
     * @throws Exception 异常
     */
    @PostMapping
    public String receiveMessage(HttpServletRequest request) throws Exception
    {
        WxMpXmlMessage wxMpXmlMessage = WxMpXmlMessage.fromXml(request.getInputStream());
        System.out.println(JSONObject.toJSONString(wxMpXmlMessage));

        return "success";
    }

    private Map<String, String> parseXml(HttpServletRequest request) throws Exception
    {
        Map<String, String> map = new HashMap<>();
        InputStream inputStream = request.getInputStream();
        SAXReader reader = new SAXReader();
        Document document = reader.read(inputStream);
        Element root = document.getRootElement();
        List<Element> elementList = root.elements();

        for (Element e : elementList)
        {
            map.put(e.getName(), e.getText());
        }

        inputStream.close();
        inputStream = null;

        return map;
    }
}
```

#### 3、配置内网穿透(ngrok)

##### 3.1、注册用户

网址：https://ngrok.cc/login/register

![注册用户](https://img-blog.csdnimg.cn/b6255e993e0041919659b3096f8054b0.png)

##### 3.2、实名认证

**（1）注册成功之后，登录系统，进行实名认证，认证费 2 元，认证通过后才能开通隧道。**

![实名认证](https://img-blog.csdnimg.cn/81784c23ebe240e5872c88836dba8237.png)

##### 3.3、开通隧道

**（1）选择隧道管理 -> 开通隧道。**

**最后一个是免费服务器，建议选择付费服务器，10 元/月，因为免费服务器使用人数很多，经常掉线。**

![开通隧道](https://img-blog.csdnimg.cn/f2a83b39b9f4495b8955eb981cd47946.png)

**（2）点击立即购买 -> 输入相关信息。**

![开通隧道](https://img-blog.csdnimg.cn/d0df65ecd63a496daab9d1dd430e7c78.png)

**（3）开通成功后，查看开通的隧道。**

**这里开通了两个隧道，一个用于后端接口调用，一个用于公众号前端调用。**

![开通隧道](https://img-blog.csdnimg.cn/14eef8f625bf4fc2b1665b74f04536de.png)

![开通隧道](https://img-blog.csdnimg.cn/8d8b863f1789486e8a639add7eb1966d.png)

##### 3.4、启动隧道

**（1）下载客户端工具。**

![启动隧道](https://img-blog.csdnimg.cn/e95a0cb0438f43b893e5b87e89fbf9c4.png)

**（2）选择 windows 版本。**

![启动隧道](https://img-blog.csdnimg.cn/5e19e1db10234721a0504f9e68733e0b.png)

**（3）解压，找到 bat 文件，双击启动。**

![启动隧道](https://img-blog.csdnimg.cn/0c2c83a165cb464d8aac4c03ec70e81f.png)

**（4）输入隧道 id，多个使用逗号隔开，最后回车就可以启动。**

![启动隧道](https://img-blog.csdnimg.cn/49e3b089b0cb405c9030a7985d08d7c2.png)

![启动隧道](https://img-blog.csdnimg.cn/789fedbeef1448babc50e62d3b0e7229.png)

##### 3.5、测试

**启动服务，在智慧星球公众号发送文本消息测试效果。**

#### 4、消息业务实现

##### 4.1、service-vod 模块创建接口

**（1）创建 CourseApiController 方法，根据课程关键字查询课程信息。**

![service-vod 模块创建接口](https://img-blog.csdnimg.cn/52cd8edd79ab4e31ba3f34d5e84462d0.png)

```java
package com.myxh.smart.planet.vod.api;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.myxh.smart.planet.model.vod.Course;
import com.myxh.smart.planet.vod.service.CourseService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@RestController
@RequestMapping("/api/vod/course")
public class CourseApiController
{
    @Autowired
    private CourseService courseService;

    /**
     * 根据关键字查询课程
     * @param keyword 关键字
     * @return courseList 课程信息
     */
    @Operation(summary = "根据关键字查询课程", description = "根据关键字查询课程")
    @GetMapping("inner/find/by/keyword/{keyword}")
    public List<Course> findByKeyword(
            @Parameter(name = "keyword",description = "关键字", required = true)
            @PathVariable("keyword") String keyword)
    {
        QueryWrapper<Course> queryWrapper = new QueryWrapper<>();
        queryWrapper.like("title", keyword);
        List<Course> courseList = courseService.list(queryWrapper);

        return courseList;
    }
}
```

##### 4.2、创建模块定义接口

**（1）service-client 下创建子模块 service-course-client。**

![创建模块定义接口](https://img-blog.csdnimg.cn/0c5c410f5b0b489cbae8006a3ed7004f.png)

**（2）定义根据关键字查询课程接口。**

```java
package com.myxh.smart.planet.client.course;

import com.myxh.smart.planet.model.vod.Course;
import io.swagger.v3.oas.annotations.Operation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import java.util.List;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@FeignClient("service-vod")
public interface CourseFeignClient
{
    @Operation(summary = "根据关键字查询课程", description = "根据关键字查询课程")
    @GetMapping("/api/vod/course/inner/find/by/keyword/{keyword}")
    List<Course> findByKeyword(@PathVariable("keyword") String keyword);
}
```

##### 4.3、service-wechat 引入依赖

```xml
<!-- service-course-client -->
<dependency>
    <groupId>com.myxh.smart.planet</groupId>
    <artifactId>service-course-client</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

##### 4.4、service-wechat 模块实现方法

**（1）MessageService**

```java
package com.myxh.smart.planet.wechat.service;

import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/17
 */
public interface MessageService
{
    /**
     * 接收微信服务器发送来的消息
     *
     * @param param 请求参数
     * @return message 消息
     */
    String receiveMessage(Map<String, String> param);
}
```

**（2）MessageServiceImpl**

```java
package com.myxh.smart.planet.wechat.service.impl;

import com.myxh.smart.planet.client.course.CourseFeignClient;
import com.myxh.smart.planet.model.vod.Course;
import com.myxh.smart.planet.wechat.service.MessageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Random;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@Service
public class MessageServiceImpl implements MessageService
{
    @Autowired
    private CourseFeignClient courseFeignClient;

    /**
     * 接收微信服务器发送来的消息
     *
     * @param param 请求参数
     * @return message 消息
     */
    @Override
    public String receiveMessage(Map<String, String> param)
    {
        String content;

        try
        {
            String msgType = param.get("MsgType");

            // 判断是什么类型消息
            switch (msgType)
            {
                // 普通文本类型，输入关键字 Java
                case "text":
                    content = this.search(param);
                    break;
                // 事件类型
                case "event":
                    String event = param.get("Event");
                    String eventKey = param.get("EventKey");

                    if ("subscribe".equals(event))
                    {
                        // 关注公众号
                        content = this.subscribe(param);
                    }
                    else if ("unsubscribe".equals(event))
                    {
                        // 取消关注公众号
                        content = this.unsubscribe(param);
                    }
                    else if ("CLICK".equals(event) && "aboutUs".equals(eventKey))
                    {
                        // 关于我们
                        content = this.aboutUs(param);
                    }
                    else
                    {
                        content = "success";
                    }
                    break;
                default:
                    // 其他情况
                    content = "success";
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            content = this.text(param, "请重新输入关键字，没有匹配到相关视频课程").toString();
        }

        return content;
    }

    /**
     * 处理关键字搜索事件
     * 图文消息个数；当用户发送文本、图片、语音、视频、图文、地理位置这六种消息时，开发者只能回复 1 条图文消息；其余场景最多可回复 8 条图文消息
     *
     * @param param 请求参数
     * @return message 消息
     */
    private String search(Map<String, String> param)
    {
        String fromUsername = param.get("FromUserName");
        String toUsername = param.get("ToUserName");
        String content = param.get("Content");

        // 单位为秒，不是毫秒
        long createTime = new Date().getTime() / 1000;
        StringBuffer text = new StringBuffer();
        List<Course> courseList = courseFeignClient.findByKeyword(content);

        if (CollectionUtils.isEmpty(courseList))
        {
            text = this.text(param, "请重新输入关键字，没有匹配到相关视频课程");
        }
        else
        {
            // 一次只能返回一个
            Random random = new Random();
            int num = random.nextInt(courseList.size());
            Course course = courseList.get(num);

            String articles = "<item>" +
                    "<Title><![CDATA[" + course.getTitle() + "]]></Title>" +
                    "<Description><![CDATA[" + course.getTitle() + "]]></Description>" +
                    "<PicUrl><![CDATA[" + course.getCover() + "]]></PicUrl>" +
                    "<Url><![CDATA[http://smartplanetmobile.free.idcfengye.com/#/live/info/" + course.getId() + "]]></Url>" +
                    "</item>";

            text.append("<xml>");
            text.append("<ToUserName><![CDATA[").append(fromUsername).append("]]></ToUserName>");
            text.append("<FromUserName><![CDATA[").append(toUsername).append("]]></FromUserName>");
            text.append("<CreateTime><![CDATA[").append(createTime).append("]]></CreateTime>");
            text.append("<MsgType><![CDATA[news]]></MsgType>");
            text.append("<ArticleCount><![CDATA[1]]></ArticleCount>");
            text.append("<Articles>");
            text.append(articles);
            text.append("</Articles>");
            text.append("</xml>");
        }

        return text.toString();
    }

    /**
     * 回复文本
     *
     * @param param   请求参数
     * @param content 上下文
     * @return message 消息
     */
    private StringBuffer text(Map<String, String> param, String content)
    {
        String fromUsername = param.get("FromUserName");
        String toUsername = param.get("ToUserName");

        // 单位为秒，不是毫秒
        long createTime = new Date().getTime() / 1000;
        StringBuffer text = new StringBuffer();

        text.append("<xml>");
        text.append("<ToUserName><![CDATA[").append(fromUsername).append("]]></ToUserName>");
        text.append("<FromUserName><![CDATA[").append(toUsername).append("]]></FromUserName>");
        text.append("<CreateTime><![CDATA[").append(createTime).append("]]></CreateTime>");
        text.append("<MsgType><![CDATA[text]]></MsgType>");
        text.append("<Content><![CDATA[").append(content).append("]]></Content>");
        text.append("</xml>");

        return text;
    }

    /**
     * 处理关注事件
     *
     * @param param 请求参数
     * @return message 消息
     */
    private String subscribe(Map<String, String> param)
    {
        return this.text(param, "感谢你关注“智慧星球”，可以根据关键字搜索你想看的视频教程，如：Java 基础、Spring Boot、大数据等。").toString();
    }

    /**
     * 处理取消关注事件
     *
     * @param param 请求参数
     * @return message 消息
     */
    private String unsubscribe(Map<String, String> param)
    {
        return "success";
    }

    /**
     * 关于我们
     *
     * @param param 请求参数
     * @return message 消息
     */
    private String aboutUs(Map<String, String> param)
    {
        StringBuffer message = this.text(param, "智慧星球现开设 Java、HTML5 前端 + 全栈、大数据、全链路 UI/UE 设计、人工智能、大数据运维 + Python 自动化、Android + HTML5 混合开发等多门课程；" +
                "同时，通过视频分享、智慧星球在线课堂、大厂学苑直播课堂等多种方式，满足了全国编程爱好者对多样化学习场景的需求，已经为行业输送了大量 IT 技术人才。");

        return message.toString();
    }
}
```

##### 4.5、更改 MessageController 方法

```java
package com.myxh.smart.planet.wechat.controller;

import com.myxh.smart.planet.wechat.service.MessageService;
import jakarta.servlet.http.HttpServletRequest;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@RestController
@RequestMapping("/api/wechat/message")
public class MessageController
{
    @Autowired
    private MessageService messageService;

    /**
     * 接收微信服务器发送来的消息
     *
     * @param request 请求
     * @return message 消息
     * @throws Exception 异常
     */
    @PostMapping
    public String receiveMessage(HttpServletRequest request) throws Exception
    {
        /*
        WxMpXmlMessage wxMpXmlMessage = WxMpXmlMessage.fromXml(request.getInputStream());
        System.out.println(JSONObject.toJSONString(wxMpXmlMessage));

        return "success";
         */

        Map<String, String> param = this.parseXml(request);
        String message = messageService.receiveMessage(param);

        return message;
    }

    private Map<String, String> parseXml(HttpServletRequest request) throws Exception
    {
        Map<String, String> map = new HashMap<>();
        InputStream inputStream = request.getInputStream();
        SAXReader reader = new SAXReader();
        Document document = reader.read(inputStream);
        Element root = document.getRootElement();
        List<Element> elementList = root.elements();

        for (Element e : elementList)
        {
            map.put(e.getName(), e.getText());
        }

        inputStream.close();
        inputStream = null;

        return map;
    }
}
```

#### 5、测试公众号消息

**（1）点击个人 -> 关于我们，返回关于我们的介绍。**

![测试公众号消息](https://img-blog.csdnimg.cn/e152a55907de441e8cc0196f743306cb.png)

**（2）在公众号输入关键字，返回搜索的课程信息。**

![测试公众号消息](https://img-blog.csdnimg.cn/e1c507ec36a049799e48cdbb0567b226.png)

### 二、公众号模板消息

#### 1、实现目标

购买课程支付成功微信推送消息。

#### 2、模板消息实现

接口文档：https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html

#### 3、申请模板消息

首先需要知道，模板消息是需要申请的。

但是在申请时还是有一些东西要注意，这个在官方的文档有非常详细的说明。

https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Operation_Specifications.html

![申请模板消息](https://img-blog.csdnimg.cn/21568d4ad8cf4c76a74cd4ff3732cae2.png)

这个好好看看。选择行业的时候可要谨慎些，因为这个一个月只可以修改一次。

下面看看在哪里申请，智慧星球已经申请过，忽略。

![申请模板消息](https://img-blog.csdnimg.cn/32e4d576dad4440f8c62f3012535d052.png)

申请之后就耐心等待，审核通过之后就会出现“广告与服务”模板消息的菜单。

![申请模板消息](https://img-blog.csdnimg.cn/d218a7c6fed849299235e54ae7b86bfd.png)

#### 4、添加模板消息

审核通过之后，就可以添加模板消息，进行开发了。

点击模板消息进入后，直接在模板库中选择你需要的消息模板添加就可以了，添加之后就会在我的模板中。会有一个模板 id，这个模板 id 在发送消息的时候会用到。

模板消息如下：

![添加模板消息](https://img-blog.csdnimg.cn/7abf6395f6ea42d09dd479844c322249.png)

需要模板消息：

​1、订单支付成功通知。

模板库中没有的模板，可以自定义模板，审核通过后可以使用。

#### 5、公众号测试号申请模板消息

##### 5.1、新增测试模板

![新增测试模板](https://img-blog.csdnimg.cn/eecd8cb8e47e4c3a9866b5d7691b65ea.png)

##### 5.2、填写信息

**（1）下载示例参考。**

下载地址：https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Operation_Specifications.html

![下载示例参考](https://img-blog.csdnimg.cn/22b4201a366649508e97de7488b539da.png)

![下载示例参考](https://img-blog.csdnimg.cn/d8bb9807976d41b6ad37b33bc35b3360.png)

**（2）填写模板标题和模板内容。**

![填写模板标题和模板内容](https://img-blog.csdnimg.cn/3cda5f9748aa49f7ab3c98b4ce71dc99.png)

#### 6、模板消息接口封装

##### 6.1、MessageController

**添加方法。**

```java
package com.myxh.smart.planet.wechat.controller;

import com.myxh.smart.planet.result.Result;
import com.myxh.smart.planet.wechat.service.MessageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@RestController
@RequestMapping("/api/wechat/message")
public class MessageController
{
    @Autowired
    private MessageService messageService;

    /**
     * 推送支付消息
     *
     * @return Result 全局统一返回结果
     */
    @GetMapping("/push/pay/message")
    public Result<Void> pushPayMessage()
    {
        messageService.pushPayMessage(1L);

        return Result.ok(null);
    }
}
```

##### 6.2、service 接口

**MessageService**

```java
package com.myxh.smart.planet.wechat.service;

/**
 * @author MYXH
 * @date 2023/10/17
 */
public interface MessageService
{
    /**
     * 推送支付消息，订单成功
     */
    void pushPayMessage(long orderId);
}
```

##### 6.3、service 接口实现

**（1）MessageServiceImpl 类。**

**（2）openid 值。**

![openid 值](https://img-blog.csdnimg.cn/8fe28fd55c5a406d9d72b18d1e32a9af.png)

**（3）模板 id 值。**

![模板 id 值](https://img-blog.csdnimg.cn/0cee3586e2794f05abc56a940c431de1.png)

```java
package com.myxh.smart.planet.wechat.service.impl;

import com.myxh.smart.planet.wechat.service.MessageService;
import lombok.SneakyThrows;
import me.chanjar.weixin.mp.api.WxMpService;
import me.chanjar.weixin.mp.bean.template.WxMpTemplateData;
import me.chanjar.weixin.mp.bean.template.WxMpTemplateMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author MYXH
 * @date 2023/10/17
 */
@Service
public class MessageServiceImpl implements MessageService
{
    @Autowired
    private WxMpService wxMpService;

    /**
     * 推送支付消息，订单成功
     * 暂时写成固定值测试，后续完善
     */
    @SneakyThrows
    @Override
    public void pushPayMessage(long orderId)
    {
        // 微信 openid
        String openid = "oxM4d64iKq9SD6lduBKcF4MQTjF8";
        WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder()
                // 要推送的用户 openid
                .toUser(openid)
                // 模板 id
                .templateId("URQAUtz9-IrYVFwsuI5Ul4pKUcRFKGmOTwRAb6lscJM")
                // 点击模板消息要访问的网址
                .url("http://smartplanet.free.idcfengye.com/#/pay/" + orderId)
                .build();

        // 如果是正式版发送消息，这里需要配置信息
        templateMessage.addData(new WxMpTemplateData("first", "亲爱的用户：您有一笔订单支付成功。", "#272727"));
        templateMessage.addData(new WxMpTemplateData("keyword1", "20231123180908744", "#272727"));
        templateMessage.addData(new WxMpTemplateData("keyword2", "Java基础课程", "#272727"));
        templateMessage.addData(new WxMpTemplateData("keyword3", "2023-11-23", "#272727"));
        templateMessage.addData(new WxMpTemplateData("keyword4", "100", "#272727"));
        templateMessage.addData(new WxMpTemplateData("remark", "感谢你购买课程，如有疑问，随时咨询！", "#272727"));
        String message = wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage);
        System.out.println(message);
    }
}
```

##### 6.4、通过 swagger 测试效果

**（1）在公众号可以看到发送的模板消息。**

![通过 swagger 测试效果](https://img-blog.csdnimg.cn/e7f3ffc9be9e4335893308052a7a9006.png)

### 三、微信授权登录

#### 1、需求描述

根据流程图通过菜单进入的页面都要授权登录

![需求描述](https://img-blog.csdnimg.cn/9c2d29f7edf44597accb0487db078b8d.png)

#### 2、授权登录

接口文档：https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html

说明：

​1、严格按照接口文档实现。

2、应用授权作用域 scope：scope 为 snsapi_userinfo。

##### 2.1、配置授权回调域名

**（1）在公众号正式号配置。**

在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“设置与开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是 URL，因此请勿加 http:// 等协议头。

本地测试配置内网穿透地址。

![在公众号正式号配置](https://img-blog.csdnimg.cn/26190fa8ae324b119f8c1db7e23ecd0d.png)

**（2）在公众号测试号配置。**

![在公众号测试号配置](https://img-blog.csdnimg.cn/044b53a4dfed428bab0c6b551e9d5a17.png)

![在公众号测试号配置](https://img-blog.csdnimg.cn/00dcc6bb378741f0b24e814bb9a19892.png)

##### 2.2、部署公众号前端页面

**（1）公众号前端页面已经开发完成，直接部署使用即可。**

![部署公众号前端页面](https://img-blog.csdnimg.cn/ab0e53e2bc6240abac20eecf3f8b1580.png)

**（2）启动公众号页面项目**

**使用命令：npm run serve。**

![部署公众号前端页面](https://img-blog.csdnimg.cn/13b0b9f475014cf9a861041cc3f9d20c.png)

##### 2.3、前端处理

**（1）全局处理授权登录，处理页面：/src/App.vue。**

**说明 1：访问页面时首先判断是否有 token 信息，如果没有跳转到授权登录接口。**

**说明 2：通过 localStorage 存储 token 信息。**

在 HTML5 中，加入了一个**localStorage**特性，这个特性主要是用来作为本地存储来使用的，解决了 cookie 存储空间不足的问题(cookie 中每条 cookie 的存储空间很小，只有几 K)，localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同。它只能存储字符串格式的数据，所以最好在每次存储时把数据转换成 json 格式，取出的时候再转换回来。

**（2）前端代码实现。**

```javascript
<template>
  <div id="app">
    <div id="nav">
      <!-- <router-link to="/">列表页</router-link> | -->
      <!-- <router-link to="/info">详情页</router-link> | -->
      <!-- <router-link to="/list">列表页</router-link> | -->
      <!-- <router-link to="/order">下单页</router-link> -->
      <van-button round block type="info" @click="clearData"
        >清空 localStorage</van-button
      >
    </div>
    <router-view />
  </div>
</template>

<script>
import userInfoAPI from "@/api/userInfo";

export default {
  data() {
    return {
      show: true,
    };
  },

  created() {
    // 处理微信授权登录
    this.wechatLogin();
  },

  methods: {
    wechatLogin() {
      // 处理微信授权登录
      let token = this.getQueryString("token") || "";

      if (token != "") {
        window.localStorage.setItem("token", token);
      }

      // 所有页面都必须登录，两次调整登录，这里与接口返回 208 状态
      token = window.localStorage.getItem("token") || "";

      if (token == "") {
        let url = window.location.href.replace("#", "smartplanet");
        window.location =
          "http://smartplanet.free.idcfengye.com/api/user/wechat/authorize?returnUrl=" +
          url;
      }

      console.log("token：" + window.localStorage.getItem("token"));

      //绑定手机号处理
      /*
      if (token != "") {
        this.bindPhone();
      }
       */
    },

    bindPhone() {
      let userInfoString = window.localStorage.getItem("userInfo") || "";
      alert("userInfoString:" + userInfoString);

      if (userInfoString != "") {
        alert("userInfoString:" + userInfoString);
        let userInfo = JSON.parse(userInfoString);
        let phone = userInfo.phone || "";

        if (phone == "") {
          this.$router.push({ path: "/bindFirst" });
        }
      } else {
        alert("userInfoString:" + userInfoString);
        userInfoAPI.getCurrentUserInfo().then((response) => {
          window.localStorage.setItem(
            "userInfo",
            JSON.stringify(response.data)
          );
          alert("data:" + JSON.stringify(response.data));
          let phone = response.data.phone || "";
          console.log("phone:" + phone);

          if (phone == "") {
            this.$router.push({ path: "/bindFirst" });
          }
        });
      }
    },

    getQueryString(paramName) {
      if (window.location.href.indexOf("?") == -1) return "";

      let searchString = window.location.href.split("?")[1];
      let i,
        val,
        params = searchString.split("&");

      for (i = 0; i < params.length; i++) {
        val = params[i].split("=");

        if (val[0] == paramName) {
          return val[1];
        }
      }

      return "";
    },

    clearData() {
      window.localStorage.setItem("token", "");
      window.localStorage.setItem("userInfo", "");
      let token = window.localStorage.getItem("token");
      alert("token:" + token);
    },
  },
};
</script>

<style lang="scss">
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
}
</style>
```

#### 3、授权登录接口

**操作模块：service-user。**

##### 3.1、引入微信工具包

```xml
<!-- aliyun-java-sdk-core -->
<dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>aliyun-java-sdk-core</artifactId>
</dependency>

<!-- weixin-java-mp -->
<dependency>
    <groupId>com.github.binarywang</groupId>
    <artifactId>weixin-java-mp</artifactId>
    <version>4.5.0</version>
</dependency>

<!-- dom4j -->
<dependency>
    <groupId>dom4j</groupId>
    <artifactId>dom4j</artifactId>
    <version>1.4</version>
</dependency>
```

##### 3.2、添加配置

```properties
# 公众号 id 和秘钥
# 智慧星球微信公众平台 appId
wechat.appId=wxc23b80b9ffaac7bd
# 智慧星球微信公众平台 api 秘钥
wechat.appSecret=5c0271622c4271753310c436b5cd3532

# 授权回调获取用户信息接口地址
wechat.userInfoUrl: http://smartplanet.free.idcfengye.com/api/user/wechat/user/info
```

##### 3.3、添加工具类

```java
package com.myxh.smart.planet.user.utils;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * @author MYXH
 * @date 2023/10/18
 * @description 常量类，读取配置文件 application.properties 中的配置
 */
@Component
public class ConstantPropertiesUtil implements InitializingBean
{
    @Value("${wechat.appId}")
    private String appId;

    @Value("${wechat.appSecret}")
    private String appSecret;

    public static String ACCESS_KEY_ID;
    public static String ACCESS_KEY_SECRET;

    @Override
    public void afterPropertiesSet() throws Exception
    {
        ACCESS_KEY_ID = appId;
        ACCESS_KEY_SECRET = appSecret;
    }
}
```

```java
package com.myxh.smart.planet.user.config;

import com.myxh.smart.planet.user.utils.ConstantPropertiesUtil;
import me.chanjar.weixin.mp.api.WxMpService;
import me.chanjar.weixin.mp.api.impl.WxMpServiceImpl;
import me.chanjar.weixin.mp.config.WxMpConfigStorage;
import me.chanjar.weixin.mp.config.impl.WxMpDefaultConfigImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

/**
 * @author MYXH
 * @date 2023/10/18
 */
@Component
public class WeChatMpConfig
{
    @Autowired
    public WeChatMpConfig(ConstantPropertiesUtil constantPropertiesUtil)
    {

    }

    @Bean
    public WxMpService wxMpService(WxMpConfigStorage wxMpConfigStorage)
    {
        WxMpService wxMpService = new WxMpServiceImpl();
        wxMpService.setWxMpConfigStorage(wxMpConfigStorage);

        return wxMpService;
    }

    @Bean
    public WxMpConfigStorage wxMpConfigStorage()
    {
        WxMpDefaultConfigImpl wxMpConfigStorage = new WxMpDefaultConfigImpl();
        wxMpConfigStorage.setAppId(ConstantPropertiesUtil.ACCESS_KEY_ID);
        wxMpConfigStorage.setSecret(ConstantPropertiesUtil.ACCESS_KEY_SECRET);

        return wxMpConfigStorage;
    }
}
```

##### 3.4、controller 类

```java
package com.myxh.smart.planet.user.api;

import com.alibaba.fastjson2.JSON;
import com.myxh.smart.planet.jwt.JwtHelper;
import com.myxh.smart.planet.model.user.UserInfo;
import com.myxh.smart.planet.user.service.UserInfoService;
import jakarta.servlet.http.HttpServletRequest;
import me.chanjar.weixin.common.api.WxConsts;
import me.chanjar.weixin.common.bean.WxOAuth2UserInfo;
import me.chanjar.weixin.common.bean.oauth2.WxOAuth2AccessToken;
import me.chanjar.weixin.common.error.WxErrorException;
import me.chanjar.weixin.mp.api.WxMpService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

/**
 * @author MYXH
 * @date 2023/10/18
 */
@Controller
@RequestMapping("/api/user/wechat")
public class WechatController
{
    @Autowired
    private UserInfoService userInfoService;

    @Autowired
    private WxMpService wxMpService;

    @Value("${wechat.userInfoUrl}")
    private String userInfoUrl;

    /**
     * 授权跳转
     *
     * @param returnUrl 返回 url
     * @param request   请求
     * @return redirectURL 重定向 url
     */
    @GetMapping("/authorize")
    public String authorize(@RequestParam("returnUrl") String returnUrl, HttpServletRequest request)
    {
        String redirectURL = wxMpService.getOAuth2Service().buildAuthorizationUrl(userInfoUrl,
                WxConsts.OAuth2Scope.SNSAPI_USERINFO,
                URLEncoder.encode(returnUrl.replace("#", "smartplanet"), StandardCharsets.UTF_8));

        return "redirect:" + redirectURL;
    }

    /**
     * 获取用户信息
     *
     * @param code      密码
     * @param returnUrl 返回 url
     * @return redirectURL 重定向 url
     */
    @GetMapping("/user/info")
    public String userInfo(@RequestParam("code") String code,
                           @RequestParam("state") String returnUrl)
    {
        try
        {
            // 拿着 code 发送请求
            WxOAuth2AccessToken wxOAuth2AccessToken = this.wxMpService.getOAuth2Service().getAccessToken(code);

            // 获取 openId
            String openId = wxOAuth2AccessToken.getOpenId();
            System.out.println("微信网页授权 openId = " + openId);

            // 获取微信信息
            WxOAuth2UserInfo wxOAuth2UserInfo = wxMpService.getOAuth2Service().getUserInfo(wxOAuth2AccessToken, null);
            System.out.println("微信网页授权 wxOAuth2UserInfo = " + JSON.toJSONString(wxOAuth2UserInfo));

            // 获取微信信息添加到数据库
            UserInfo userInfo = userInfoService.getUserInfoByOpenid(openId);

            if (userInfo == null)
            {
                userInfo = new UserInfo();
                userInfo.setOpenId(openId);
                userInfo.setUnionId(wxOAuth2UserInfo.getUnionId());
                userInfo.setNickName(wxOAuth2UserInfo.getNickname());
                userInfo.setAvatar(wxOAuth2UserInfo.getHeadImgUrl());
                userInfo.setSex(wxOAuth2UserInfo.getSex());
                userInfo.setProvince(wxOAuth2UserInfo.getProvince());
                userInfoService.save(userInfo);
            }

            // 生成 token，按照一定规则生成字符串，可以包含用户信息
            String token = JwtHelper.createToken(userInfo.getId(), userInfo.getNickName());

            // 授权完成之后，跳转具体功能页面
            if (!returnUrl.contains("?"))
            {
                return "redirect:" + returnUrl + "?token=" + token;
            }
            else
            {
                return "redirect:" + returnUrl + "&token=" + token;
            }
        }
        catch (WxErrorException e)
        {
            e.printStackTrace();
        }

        return null;
    }
}
```

##### 3.5、编写 UserInfoService

```java
package com.myxh.smart.planet.user.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.myxh.smart.planet.model.user.UserInfo;
import com.myxh.smart.planet.user.mapper.UserInfoMapper;
import com.myxh.smart.planet.user.service.UserInfoService;
import org.springframework.stereotype.Service;

/**
 * @author MYXH
 * @date 2023/10/15
 *
 * <p>
 * 用户信息 服务实现类
 * </p>
 */
@Service
public class UserInfoServiceImpl extends ServiceImpl<UserInfoMapper, UserInfo> implements UserInfoService
{
    /**
     * 根据 openId 获取用户信息
     *
     * @param openId openId openId
     * @return userInfo 用户信息
     */
    @Override
    public UserInfo getUserInfoByOpenid(String openId)
    {
        QueryWrapper<UserInfo> wrapper = new QueryWrapper<>();
        wrapper.eq("open_id", openId);
        UserInfo userInfo = baseMapper.selectOne(wrapper);

        return userInfo;
    }
}
```

##### 3.6、使用 token

**通过 token 传递用户信息。**

###### 3.6.1、JWT 介绍

**JWT 工具。**

JWT（Json Web Token）是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准。

JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上

JWT 最重要的作用就是对 token 信息的**防伪**作用。

###### 3.6.2、JWT 的原理

一个 JWT 由**三个部分组成：公共部分、私有部分、签名部分**。最后由这三者组合进行 base64 编码得到 JWT。

![JWT 的原理](https://img-blog.csdnimg.cn/93840fbaae2d492c8162f155cec067e9.png)

**（1）公共部分。**

主要是该 JWT 的相关配置参数，比如签名的加密算法、格式类型、过期时间等等。

**（2）私有部分。**

用户自定义的内容，根据实际需要真正要封装的信息。

userInfo{用户的 Id，用户的昵称 nickName}。

**（3）签名部分。**

SaltiP: 当前服务器的 IP 地址{linux 中配置代理服务器的 ip}。

主要用户对 JWT 生成字符串的时候，进行加密{盐值}。

base64 编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就可以把 base64 编码解成明文，所以不要在 JWT 中放入涉及私密的信息。

###### 3.6.3、整合 JWT

**（1）在 service-utils 模块添加依赖。**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.myxh.smart.planet</groupId>
        <artifactId>common</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>service-utils</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- httpclient -->
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpclient</artifactId>
        </dependency>

        <!-- jjwt -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
        </dependency>

        <!-- jjwt-impl -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- jjwt-jackson -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- 日期时间工具 -->
        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
        </dependency>
    </dependencies>
</project>
```

**（2）添加 JWT 工具类。**

```java
package com.myxh.smart.planet.jwt;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.util.ObjectUtils;

import java.util.Date;

/**
 * @author MYXH
 * @date 2023/10/19
 */
public class JwtHelper
{
    // token 字符串有效时间
    private static final long tokenExpiration = 24 * 60 * 60 * 1000;

    // 加密编码秘钥
    private static final String tokenSignKey = "SmartPlanetSmartPlanetSmartPlanetSmartPlanetSmartPlanetSmartPlanet";

    /**
     * 根据 userId 和 username 生成 token 字符串
     *
     * @param userId   用户 id
     * @param userName 用户姓名
     * @return token 字符串
     */
    public static String createToken(Long userId, String userName)
    {
        String token = Jwts.builder()
                // 设置 token 分类
                .setSubject("SmartPlanet-USER")

                // token 字符串有效时长
                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))

                // 私有部分（用户信息）
                .claim("userId", userId)
                .claim("userName", userName)

                // 根据秘钥使用加密编码方式进行加密，对字符串压缩
                .signWith(Keys.hmacShaKeyFor(tokenSignKey.getBytes()), SignatureAlgorithm.HS512)
                .compressWith(CompressionCodecs.GZIP)
                .compact();

        return token;
    }

    /**
     * 从 token字符串获取 userId
     *
     * @param token token字符串
     * @return 用户 id
     */
    public static Long getUserId(String token)
    {
        if (ObjectUtils.isEmpty(token))
        {
            return null;
        }

        Jws<Claims> claimsJws = Jwts.parserBuilder().setSigningKey(tokenSignKey.getBytes()).build().parseClaimsJws(token);
        Claims claims = claimsJws.getBody();
        Integer userId = (Integer) claims.get("userId");

        return userId.longValue();
    }

    /**
     * 从 token 字符串获取 userName
     *
     * @param token token字符串
     * @return userName 用户姓名
     */
    public static String getUserName(String token)
    {
        if (ObjectUtils.isEmpty(token))
        {
            return "";
        }

        Jws<Claims> claimsJws = Jwts.parserBuilder().setSigningKey(tokenSignKey.getBytes()).build().parseClaimsJws(token);
        Claims claims = claimsJws.getBody();
        String userName = (String) claims.get("userName");

        return userName;
    }

    public static void main(String[] args)
    {
        String token = JwtHelper.createToken(1L, "MYXH");
        System.out.println("token = " + token);
        System.out.println("JwtHelper.getUserId(token) = " + JwtHelper.getUserId(token));
        System.out.println("JwtHelper.getUserName(token) = " + JwtHelper.getUserName(token));
    }
}
```
